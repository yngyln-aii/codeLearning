## 数组

### 基本用法

1. **声明和初始化数组：**

```cpp
// 声明一个整数数组，指定大小为5
int myArray[5];

// 初始化数组的同时赋值
int anotherArray[3] = {10, 20, 30};
```

2. **访问数组元素：**
   数组中的元素可以通过索引（从0开始）来访问。

```cpp
int value = myArray[2]; // 访问第3个元素
```

3. **数组的大小：**
   数组的大小在声明时指定，无法动态改变。可以使用`sizeof`运算符获取数组在内存中所占的字节数。

```cpp
int size = sizeof(myArray) / sizeof(myArray[0]); // 计算数组的元素个数
```

4. **循环遍历数组：**
   使用循环结构可以遍历数组中的元素。

```cpp
for (int i = 0; i < size; ++i) {
cout << myArray[i] << " ";
}
```

5. **多维数组：**
   C++支持多维数组，例如二维数组、三维数组等。

```cpp
int twoDArray[3][4]; // 声明一个3行4列的二维数组
```

6. **数组名：**
   在C++中，数组名代表数组的首地址。例如，`myArray`表示第一个元素的地址。

```cpp
int *ptr = myArray; // ptr指向数组的第一个元素
```

7.**数组作为函数参数：**
数组可以作为函数的参数传递，但在函数中传递的是数组的指针。

```cpp
void printArray(int arr[], int size) {
   for (int i = 0; i < size; ++i) {
      cout << arr[i] << " ";
   }
}
```

## 指针&&数组

数组是“固定大小、连续存储的一段元素集合”，类型为 T[N]；指针是“存放地址的变量”，类型为 T*（指向 T 类型的对象）。数组在多数表达式中会**退化（decay）**为指向首元素的指针，但二者在类型、sizeof、可赋值性、生命期等方面有很多关键区别。

### 基本概念与类型

* 数组（compile-time 固定长度阵列）

  定义：T a[N]; —— 类型是 T[N]。内存上连续存放 N 个 T。数组名在很多场合会“变成”T*（指向第 0 个元素的指针），这叫 decay。

* 指针

  定义：T *p; —— p 是一个变量，值为一个地址（可以为 nullptr、可以改变）。p 的大小是指针大小（例如 64 位系统常为 8 字节），与 T 的个数无关。

### 内存与 sizeof 行为（关键区别）

```c
int a[10];
int *p = a;
```

sizeof(a) → 10 * sizeof(int)（数组整体大小）。
sizeof(p) → 指针大小（例如 8），与数组元素个数无关。
注意：数组在以下情形不会退化：sizeof(a)、&a、以及绑定到数组引用（T (&)[N]）时。

```c
int a[10];
int *p = a;
// 常见输出（实际取决于平台）
sizeof(a) == 40; // if sizeof(int)==4
sizeof(p) == 8;  // 指针大小
```

### arr、&arr、&arr[0] 四种“地址”的类型差别
假设 int a[10];

* a 在大多数表达式中等价于 &a[0]，类型为 int\*（指向第 0 个元素）。

* &a[0] 类型为 int\*（地址与 a 的数值相同）。

* &a 类型为 int (\*)[10]（指向整个数组的指针），数值（地址）与 a 和 &a[0] 相同，但类型不同。

  这意味着指针算术行为也不同：(&a) + 1 跳过整个数组（10 * sizeof(int)），而 (a) + 1 跳过一个 int（sizeof(int)）。

### 下标与指针算术的等价性
* a[i] 等价于 *(a + i)。

* 指针算术会按元素类型大小移动：p + 1 实际地址增加 sizeof(T)。

  注意：只有当指针指向同一数组（或 one-past-the-end）时，进行比较或算术才是定义良好的；越界访问是 UB（未定义行为）。

```c
int a[3] = {10,20,30};
int *p = a;         // 指向 a[0]
p[1] == a[1];       // true
*(p + 2) == a[2];   // true
```

### 赋值、可重定位性
* 指针是变量：可以改变指向 p = q; p = &x;。

* 数组名不是可赋值对象：不能对数组名赋新地址（a = p; 编译错误）。数组不能被重新“指向”别处。数组整体也不能通过 = 直接赋值（C++11 起支持聚合拷贝初始化，但数组间直接赋值仍然不允许）。

* 数组可以初始化（定义时），但不能用 = 给已有数组赋值（例外：使用 std::array 可以赋值）。

### 在函数参数中的表现-退化的危害
声明：

```c
void f(int a[]);    // 等价于 void f(int *a)
void g(int a[10]);  // 仍然等价于 void g(int *a)
```

函数参数中的数组会退化为指针，函数里无法得知原数组长度。要保留长度：

```c
template<size_t N>
void h(int (&a)[N]) { /* N 可用 */ }
```

或使用 std::array<T,N> / std::span<T> / vector<T>。

### 指向数组的指针（T (*p)[N]）与指向元素的指针（T *p）
* T (\*p)[N] —— 指向“整个数组”的指针。若 int b\[5][10];，则 b 是 int \[5][10]， b + 1 跳过一个 int[10]（即 10 个 int）。
* 对于二维数组 int b\[M][N];，b 的类型在大多数表达式里会退化为 int (\*)[N]（指向每行的指针），不是 int**。因此 int** 与 int (\*)[N] 并不等价。

```cint b[3][4];
int (*prow)[4] = b;      // prow 指向一个 int[4]
prow + 1;                // 地址增加 sizeof(int[4]) == 4 * sizeof(int)
```

### 动态数组（new[] / malloc）与数组字面量的区别
* new T[N] 返回 T*（指向首元素），必须用 delete[] 释放。

```c
int *p = new int[10];
delete[] p;
```

* malloc 返回 void*，不执行构造函数（在 C++ 中优先使用 new 或标准容器）。

* std::vector<T> 和 std::unique_ptr<T[]>/std::shared_ptr<T[]> 提供 RAII 管理，推荐使用现代容器代替手动 new[]。

### 字符串字面量的特殊注意（char[] vs char*）
* 字符串字面量类型为 const char[N]（带有静态存储期），应用作 const char*：const char* s = "abc";。

* char s[] = "abc"; —— 会拷贝到可修改的数组（局部或全局），你可以修改 s[0]。

* 不要把字符串字面量当成可修改的内存（不可写），尝试修改会是未定义行为。

### 生命周期与悬空指针（dangling pointers）
常见错误：

```c
int* f() {
    int a[10];
    return a; // 错误：返回指向栈上局部数组的指针 -> UB
}
```

正确做法：返回 std::array/std::vector，或 new[]（不推荐直接返回裸指针），或把数组声明为 static（但 static 有全局状态问题）。

### 多维数组（如何分配、连续性）

* int a\[M][N]; 是连续存储（行主序）。可以把它视为 M 个长度为 N 的一维数组联结。

* 如果用 int\** 建立二维“数组”，通常是多个单独分配的行（不连续），与 int a\[M][N] 不同。
* 要动态分配连续 M×N 区域：int* data = new int[M*N]; 然后索引 data[i\*N + j]，或者分配 new int\[M][N]（C++ 不支持直接 new VLA，需 new int\[M][N] 只能在编译期 N 已知或使用 std::vector）。

### 常用示例

```c
#include <iostream>
#include <type_traits>

int main() {
    int a[3] = {1,2,3};
    int *p = a;

    std::cout << "sizeof(a)=" << sizeof(a) << "\n"; // 3 * sizeof(int)
    std::cout << "sizeof(p)=" << sizeof(p) << "\n"; // pointer size

    std::cout << "a == &a[0] ? " << (a == &a[0]) << "\n"; // true (地址值相等)
    // 类型不同： a -> int*, &a -> int (*)[3]

    auto addr_a = reinterpret_cast<void*>(a);
    auto addr_amp = reinterpret_cast<void*>(&a);
    std::cout << "address a: " << addr_a << ", &a: " << addr_amp << "\n";

    // 指针算术
    std::cout << "*(a+1) = " << *(a+1) << ", a[1] = " << a[1] << "\n";

    // 数组不可赋值
    // int b[3];
    // b = a; // 编译错误

    return 0;
}
```
（注：reinterpret_cast 仅用于打印地址示例，实际要小心使用。）

### 常见陷阱与误区
1. 在函数里用 sizeof 来测长度——如果参数是 T a[]，sizeof 返回指针大小不是数组长度。
2. 返回指向局部数组的指针会导致悬空。
3. a == &a 地址值相同但类型不同，导致不同的指针算术语义。
4. 不要混淆 int\** 与 int (\*)[N]（不是同一对象）。
5. 动态数组用 new[] 必须用 delete[]（忘记或用 delete 会导致 UB）。
6. 字符串字面量应视为 const char[]（不要写入）。
7. 指针比较/算术只在同一数组范围内定义良好。
8. 数组不能赋值（用 std::array 可以赋值或拷贝）。
9. 指针大小与目标类型大小无关，跨平台要注意 sizeof(void*)。
10. 当需要“长度信息”和“安全性”，优先使用 std::array/std::vector/std::span。

### C++ 风格建议（现代 C++）
* 固定大小数组：用 std::array<T,N>（有值语义、可拷贝、可作为模板参数）。
* 动态大小：用 std::vector<T>（RAII，自动释放）。
* 不拥有的连续视图：用 std::span<T>（C++20），比裸指针更安全，可携带长度信息。
* 避免裸指针管理所有权：裸指针可用于观察（non-owning），但不要用于管理生命期（使用智能指针或容器）。

### 小结
* T a[N] 是数组类型，T* p 是指针类型。
* 数组通常会退化为指向首元素的指针（T\*），但是 sizeof、&、以及数组引用不会退化。
* sizeof(array) 给出整个数组大小；sizeof(ptr) 给出指针大小。
* 数组不可被赋值或重新指向；指针可以赋值和改变指向。
* 函数参数中的数组实际变成 T*，因此长度信息丢失。使用 T (&)[N] 或 std::span/std::array 保留长度。
* 多维数组 T a\[M][N] 在内存上是连续的；T** 通常不是连续的。
* 推荐使用现代容器（std::array, std::vector, std::span）以提高安全性与可读性。

### 综合示例
```c
#include <iostream>
#include <typeinfo>
#include <cstddef> // for size_t

// ======================
// 1. 测试函数参数退化
// ======================
void func_array_param(int a[]) {
    std::cout << "\n[func_array_param] sizeof(a) = " << sizeof(a)
              << " (退化为 int*)" << std::endl;
}

template <size_t N>
void func_array_ref(int (&a)[N]) {
    std::cout << "[func_array_ref] sizeof(a) = " << sizeof(a)
              << " (保持为数组类型 int[" << N << "])" << std::endl;
    std::cout << "[func_array_ref] N = " << N << std::endl;
}

// ======================
// 2. 主程序
// ======================
int main() {
    std::cout << "=== 基础数组与指针演示 ===\n";

    int a[4] = {10, 20, 30, 40};
    int *p = a;  // a 会退化为 int*

    std::cout << "\n1. sizeof 行为对比" << std::endl;
    std::cout << "sizeof(a) = " << sizeof(a) << " (4 * sizeof(int))" << std::endl;
    std::cout << "sizeof(p) = " << sizeof(p) << " (指针大小)" << std::endl;

    std::cout << "\n2. 地址和值关系" << std::endl;
    std::cout << "a      = " << static_cast<const void*>(a) << " (首元素地址)\n";
    std::cout << "&a     = " << static_cast<const void*>(&a) << " (数组整体地址)\n";
    std::cout << "&a[0]  = " << static_cast<const void*>(&a[0]) << " (首元素地址)\n";
    std::cout << "a == &a[0] ? " << std::boolalpha << (a == &a[0]) << std::endl;
    std::cout << "a == &a ? " << std::boolalpha << (a == (int*)&a) << " (地址值相同，但类型不同)" << std::endl;

    std::cout << "\n3. 指针算术" << std::endl;
    std::cout << "a      = " << static_cast<const void*>(a) << std::endl;
    std::cout << "a + 1  = " << static_cast<const void*>(a + 1) << " (跳过 1 个 int)" << std::endl;
    std::cout << "&a + 1 = " << static_cast<const void*>(&a + 1) << " (跳过整个数组)" << std::endl;

    std::cout << "\n4. 元素访问与指针偏移" << std::endl;
    std::cout << "a[2]   = " << a[2] << std::endl;
    std::cout << "*(a+2) = " << *(a + 2) << std::endl;
    std::cout << "p[3]   = " << p[3] << std::endl;

    std::cout << "\n5. 数组名不可赋值" << std::endl;
    // int b[4];
    // b = a; //  编译错误：数组名不可作为赋值左值
    std::cout << "(无法执行 a = p; 也不能 b = a; 数组名是常量地址)\n";

    std::cout << "\n6. sizeof 在函数参数中的差异" << std::endl;
    func_array_param(a);
    func_array_ref(a);

    std::cout << "\n7. 多维数组演示" << std::endl;
    int m[2][3] = { {1,2,3}, {4,5,6} };
    std::cout << "sizeof(m)  = " << sizeof(m) << " (2 * 3 * sizeof(int))" << std::endl;
    std::cout << "sizeof(m[0]) = " << sizeof(m[0]) << " (3 * sizeof(int))" << std::endl;
    std::cout << "m      = " << static_cast<const void*>(m) << std::endl;
    std::cout << "m + 1  = " << static_cast<const void*>(m + 1)
              << " (跳过一行 int[3])" << std::endl;
    std::cout << "m[0]   = " << static_cast<const void*>(m[0]) << std::endl;
    std::cout << "m[0] + 1 = " << static_cast<const void*>(m[0] + 1)
              << " (跳过一个元素)" << std::endl;

    std::cout << "\n8. 打印 typeid 区分类型\n";
    std::cout << "typeid(a).name()      = " << typeid(a).name() << std::endl;
    std::cout << "typeid(&a).name()     = " << typeid(&a).name() << std::endl;
    std::cout << "typeid(a[0]).name()   = " << typeid(a[0]).name() << std::endl;
    std::cout << "typeid(p).name()      = " << typeid(p).name() << std::endl;

    std::cout << "\n=== 程序结束 ===" << std::endl;
    return 0;
}

```
| 项目                   | 验证内容                        | 说明             |
| ---------------------- | ------------------------------- | ---------------- |
| sizeof(a) vs sizeof(p) | 数组整体大小 vs 指针大小        | 编译期常量       |
| a VS &a vs &a[0]       | 地址值相同，类型不同            | 影响指针算术     |
| 指针算术               | a+1 跳一个元素，&a+1 跳整个数组 | 展示步长差异     |
| 函数参数退化           | void f(int a[]) 退化为指针      | 长度信息丢失     |
| 模板引用捕获           | int(&a)[N] 保留长度             | 可打印 N         |
| 二维数组               | m 类型退化为 int(*)[3]          | 连续存储验证     |
| typeid 输出            | 确认真实类型                    | A4_i 表示 int[4] |



### 指针数组&数组指针

#### 1. 什么是指针数组和[数组指针](https://so.csdn.net/so/search?q=数组指针&spm=1001.2101.3001.7020)？

##### 1.1 字面意思理解

看到一个很简单的从字面意思理解 指针数组 和 数组指针 的方式 —> 在中间加个“的”：

- 指针数组：指针的数组，**本质上是个数组**，数组里面的元素是指针
- 数组指针：数组的指针，**本质上是个指针**，是一个指向数组的指针

##### 1.2 表达式判断是指针数组还是数组指针

```
int *ptr1[10];
int (*ptr2)[10];
```

如上面两种声明方式，数组指针，指针数组区分方式如下：

（1）首先得了解运算符的优先级， `() > []` 

（2）知道了运算符优先级，那我们来看：

`int *ptr1[10]`中，优先级高的是`[10]`，说明这整个表达式`ptr1`代表的是个数组，其它的都是修饰这个数组的，所以这是个指针的数组，指针数组。

`int (*ptr2)[10]`中，优先级高的是`(*ptr2)`，说明整个表达式代表的是个指针，其它的都是修饰这个指针的，所以这是个数组的指针，数组指针。

#### 2. 指针数组

##### 2.1 原理图

指针数组，指针的数组，数组里面都是指针：

![img](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_c3ff2a91e2294591b14829b24adb0f4a.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

使用时将里面的每一个元素都当作普通指针去使用就可以了。

它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每个元素都是一个指针。

例如：char *arr[]={“Sunday”,“Monday”}，存储了两个指针，第一个指针指向了字符串"Sunday"，第二个指针指向了字符串"Monday"，而sizeof(arr)=8，因为在32位平台，指针类型大小占4个字节。指针数组最重要的用途是对多个字符串进行处理操作，因为字符指针比二维数组更快更有效。

##### 2.2 示例-1

```
char *str[3] = {"lirendada","C语言","C Language"};
std::printf("str+1的值：%s\n", *(str+1));
std::printf("str+1的值：%s\n", str[1]);
std::printf("str+1的地址：%p\n", str+1);
std::printf("str+1的地址：%p\n", &str[1]);
std::printf("str+1指向的地址：%p\n", str[1]);
std::printf("str+1指向的地址：%p\n", *(str+1));
```

运行结果：

![img](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_e42772cb758245e19f4eca16ed9a3b7e.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

 **运行结果详解**

> ## `printf` 与 `%s` 的工作机制
>
> 当写：
>
> ```
> printf("%s\n", str[1]);
> ```
>
> 实际上发生的是：
>
> 1. `str[1]` 是一个 `char*` 类型的指针，它存储着字符串 "C语言" 的起始地址
> 2. `printf` 看到 `%s` 格式说明符，它期望一个 `char*` 参数
> 3. `printf` **从该指针指向的地址开始**，逐个字符输出，直到遇到空字符 `\0`
>
> `str[1]` 确实是指向字符串的指针，但：
>
> - 当用 `%s` 打印时，`printf` **使用**这个指针来访问它指向的字符串内容
> - 当用 `%p` 打印时，`printf` **显示**这个指针本身的值

（1）*(str+1) 与 str[1] 等价，都是取第1个字符串的值

（2）整体的结构可以用下图表示：数组的每个元素都是个char*指针，指向一个字符串，字符串存储在全局区，数组的元素存放在栈区。

（3）每个char*指针指向的是字符串的首地址。

![](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_320df536b86548d9b49aab280ab7eecd.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

##### 2.3 示例-2

```c
#include <stdio.h>
int main()
{
    //定义三个整型数组
	int a[5] = { 1,2,3,4,5 };
	int b[5] = { 6,4,8,3,1 };
	int c[5] = { 2,5,8,6,1 };
    //定义一个存放指向整型变量的指针的数组arr
    int* arr[] = { a,b,c };
    //通过接引用打印出三个一维数组的元素
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 5; j++)
        {
		    printf("%d ", *(arr[i]+j));
	    }
        printf("\n");
    }
	return 0;
}
/*
1 2 3 4 5
6 4 8 3 1
2 5 8 6 1
*/
```

以上对arr解引用的方式有很多，它们都是等价的，我们来举个例子: 

```c
#include<stdio.h>
int main()
{
	int i = 0;
	int a[3][4] = { {1,2,3,4} ,{5,6,7,8} ,{9,10,11,12} };//定义一个二维数组
	int* pa[3];//定义一个指针数组
	for (i = 0; i < 3; i++)//给指针数组赋值
		pa[i] = a[i];
    printf("指针数组的内容为:\n");
	for (i = 0; i < 3; i++)//打印出指针数组的内容
	{
		int j;
		for (j = 0; j < 4; j++)
			printf("%d ", *(*(pa + i) + j));
		printf("\n");
	}
    //以下均为不同方式的解引用操作
    printf("不同解引用操作的结果为:\n");
	printf("%d,%d\n", a[1][1], *(pa[1] + 1));
	printf("%d,%d\n", a[1][1], *(*(pa+1) + 1));
	printf("%d,%d\n", a[1][1], (*(pa + 1))[1]);
	printf("%d,%d\n", a[1][1], pa[1][1]);
    return 0;
}
/* 
指针数组的内容为:

1 2 3 4
5 6 7 8
9 10 11 12
不同解引用操作的结果为:
6,6
6,6
6,6
6,6
*/
```

多种解引用的等价形式：

```c
*(pa[i] + j)          //等价于 *( a[i] + j )
*(*(pa+i) + j)        //等价于 *( *(a+j) + j )
(*(pa+i))[j]          //等价于( *(a+i) )[ j ]
pa[i][j]              //等价于 a[i][j]
```

##### 2.4 补充细节

（1）字符串指针数组赋值时，每个元素必须是char*类型，也就是必须也是指针类型或能退化成指针的数组类型才可以，否则报错：

![img](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_92816716367f4e839277420c80fad81d.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

（2）二维数组与指针数组的区别

```c
char *p1[]={"lirendada","C","C++"};
char p2[][8]={"liren","C","C++"};
```

> - `*p1`，`*(p1+1)`，`*(p1+2)`：所指向的字符串常量是不规则长度的，且`sizeof(p1)=12`。
> - `p2[0]`，`p2[1]`，`p2[2]`所指向的字符串都是一定长度的，且`sizeof(p2)=24`。

（3）指针数组还可以和字符串数组相结合使用，请看下面的例子：

```c
#include <stdio.h>
int main(){
    char *str[3] = {"lirendada","C语言","C Language"};
 
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
/*
lirendada
c语言
C Language
*/
```
需要注意的是，字符数组 str 中存放的是字符串的首地址，不是字符串本身，字符串本身位于其他的内存区域，和字符数组是分开的。

也只有当指针数组中每个元素的类型都是char *时，才能像上面那样给指针数组赋值，其他类型不行。

为了便于理解，可以将上面的字符串数组改成下面的形式，它们都是等价的。

```c
#include <stdio.h>
int main(){
    char *str0 = "lirendada";
    char *str1 = "C语言";
    char *str2 = "C Language";
    char *str[3] = {str0, str1, str2};
    printf("%s\n%s\n%s\n", str[0], str[1], str[2]);
    return 0;
}
```

（4）二维数组与指针数组的区别

```c
char *p1[]={"lirendada","C","C++"};
char p2[][8]={"liren","C","C++"};
```

\*p1，\*(p1+1)，\*(p1+2)：所指向的字符串常量是不规则长度的，且sizeof(p1)=12。


p2[0]，p2[1]，p2[2]所指向的字符串都是一定长度的，且sizeof(p2)=24。




#### 3. 数组指针

##### 3.1 原理图

数组指针，数组的指针，指向数组的一个指针：

![img](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_c82036911580484eb0baf3835823ff64.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

数组指针ptr2指向一个数组的首地址。下面以一段测试代码来看下数组指针怎么使用。

##### 3.2 示例-1

```c
int a[5] = {0,1,2,3,4};
int (*ptr2)[5] = &a;
std::printf("a的地址：%p\n", &a);
std::printf("ptr2指向的地址：%p\n", ptr2);
std::printf("ptr2自身的地址：%p\n", &ptr2);
std::printf("a[1]的值： %d\n", a[1]);
std::printf("使用ptr2访问a[1]的值：%d\n", (*ptr2)[1]);
/*
ptr2 是指向整个数组的指针
*ptr2 解引用得到数组本身（相当于 a）
(*ptr2)[1] 等价于 a[1]
*/
std::printf("使用ptr2访问a[1]的值：%d\n", *((*ptr2)+1));
/*
(*ptr2) 在表达式中退化为指向第一个元素的指针（int*）
(*ptr2)+1 指针算术，移动到第二个元素
*((*ptr2)+1) 解引用得到第二个元素的值
*/
```

运行结果：

![img](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_979ed91e14714eec81a81158b71080bf.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

**运行结果详解**

（1）首先看数组指针的赋值语句：第二句 `&a`，必须带"`&`"号

```c
int a[5] = {0,1,2,3,4};
int (*ptr2)[5] = &a;
```

（2）a的地址和**ptr2指向**的地址相同，这就是数组指针的本质（也和我们上面的原理图一致），指向一个数组的首地址。

（3）ptr2自身有个地址，如果再仔细一点看，它的地址与数组首地址差了8个字节，一个地址的距离，也就是说，数组a和ptr2在栈内存空间中是挨着的。

（4）最后三行代码提供了三种访问a[1]元素的方式，这三种方式等价。读者可以先思考下为什么这三种方式是等价的。后面一起解答。

##### 3.3 二维数组指针

首先引入二维数组的定义：二维数组在概念上是二维的，有行有列，但在内存中所有的元素都是连续排列的，以下面的二维数组为例：

```c
int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
```

从概念上理解，a的分布就像一个矩阵：

1        2        3        4

5        6        7        8

9       10      11      12

从内存上理解,整个数组占用一块连续的内存:

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。

C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 arr[0] 包含 a\[0][0]、a\[0][1]、a\[0][2]、a\[0][3]。

假设数组a中第0个元素的地址为1000，那么每个一维数组的首地址如下图所示：

![img](https://i-blog.csdnimg.cn/blog_migrate/cf8540146f830ca7239af4bb5e1bb5b2.png)

为了更好的理解指针和二维数组的关系，我们先来定义一个指向 a 的指针变量 p：

```c
int (*p)[4] = a ; 
```

括号中的*表明 p 是一个指针，它指向一个数组，数组的类型为int [4]，这正是 a 所包含的每个一维数组的类型。

**[]的优先级高于*，()是必须要加的**，如果赤裸裸地写作int *p[4]，那么应该理解为int *(p[4])，p 就成了一个指针数组，而不是二维数组指针。

**对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关**，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行。数组名 a 在表达式中也会被转换为和 p 等价的指针！

概念图如以下所示：

![img](https://i-blog.csdnimg.cn/blog_migrate/9cb21b4ec0be32b651d00c7b120297a6.png)

 下面我们就来探索一下如何使用指针 p 来访问二维数组中的每个元素。按照上面的定义：


1) p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。


2) *(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素，下面的运行结果有力地证明了这一点：

```c
#include <stdio.h>
int main(){
    int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
    int (*p)[4] = a;
    printf("%d\n", sizeof(*(p+1)));
    return 0;
}
//16
```

3) *(p+1)+1表示第 1 行第 1 个元素的地址。如何理解呢？

*(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；就像一维数组的名字，在定义时或者和 sizeof、& 一起使用时才表示整个数组，出现在表达式中就会被转换为指向数组第 0 个元素的指针

4) *(*(p+1)+1)表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。

根据上面的结论，可以很容易推出以下的等价关系：

```c
a+i == p+i
a[i] == p[i] == *(a+i) == *(p+i)
a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)
```

##### 3.4 示例-2

```c
#include <stdio.h>
int main(){
    int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};
    int(*p)[4];
    int i,j;
    p=a;
    for(i=0; i<3; i++){
        for(j=0; j<4; j++) printf("%2d  ",*(*(p+i)+j));
        printf("\n");
    }
    return 0;
}
/*
 0   1   2   3
 4   5   6   7
 8   9  10   11
*/
```

---

以二维数组：`int b[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};` 为例

```c
std::printf("数组名b的地址：%p\n", b);
std::printf("b[0]的地址：%p\n", &(b[0]));
std::printf("b+1的地址：%p\n", b+1);
std::printf("b[1]的地址：%p\n", &(b[1]));
std::printf("b+1的大小：%llu\n", sizeof(*(b+1)));
std::printf("第一行第二列 b[1][2]值的访问：%d", *(*(b+1)+2));
// 输出：
// 数组名b的地址：00000000005ffe00
// b[0]的地址：00000000005ffe00
// b+1的地址：00000000005ffe10
// b[1]的地址：00000000005ffe10
// b+1的大小：16
// 第一行第二列 b[1][2]值的访问：7
```

- 数组名b代表的是整个数组的首地址，也是第0行的首地址。
- `b+1`代表的是第1行的首地址
- `*(b+1)`的大小为 16，4个int值，也就是代表第一行的所有数据
- `*(b+1)+2`，当`*(b+1)`作为表达式中的一项时，会作为这一行的首地址使用，所以 `*(b+1)` 表示第1行的首地址，再`+2`表示这一行的第2列。

二维数组指针定义方法：

```c
int (*ptr3)[4] = b;
```

> 注意在二维数组时，b前面没有了`&`符号，因为b本身就代表一个`int[4]`的数组了。

从直观上理解，*ptr3是不是就相当于代替了原来的 b[0], b[1] 和 b[2] ？所以，ptr3应该与b[0]指向相同的地址，ptr3+1与b[1]指向相同的地址。写如下代码测试上面的结论：

```c
std::printf("b[0]的地址：%p\n", &(b[0]));
std::printf("ptr3指向的地址：%p\n", ptr3);
std::printf("b[1]的地址：%p\n", &(b[1]));
std::printf("ptr3+1指向的地址：%p\n", ptr3+1);
std::printf("第一行第二列 b[1][2]值的访问：%d\n", *(*(ptr3+1)+2));
// 输出结果
// b[0]的地址：00000000005ffe00
// ptr3指向的地址：00000000005ffe00
// b[1]的地址：00000000005ffe10
// ptr3+1指向的地址：00000000005ffe10
// 第一行第二列 b[1][2]值的访问：7
```

#### 4. 总结

总结一下数组指针与指针数组的区别：

（1）数组指针是指向数组的指针，本质是一个指针；指针数组是元素全都是指针的数组，本质是一个数组。

（2）基于两者的本质区别，数组指针大小就是4字节（32位平台）或8字节（64位平台），而指针数组的大小不止取决于平台的位数，还取决于数组的大小。

（3）最后再上一个区别的图，都以一个二维数组为例：数组指针指向这个二维数组首行首元素的地址。指针数组首先是包含3个指针，每个指针指向一行的首元素地址。

![img](https://ucc.alicdn.com/pic/developer-ecology/scmudiyedjhs2_4b489c2a403a477a87d5ffc0f30c18fb.png?x-oss-process=image%2Fresize%2Cw_1400%2Cm_lfit%2Fformat%2Cwebp)

#### 5. 补充问题

`a`为一维数组，为什么下面的打印`a`与`&a`地址是相同的？

```c
std::printf("a的地址：%p\n", a);  // 输出：00000000005ffe40
std::printf("a的地址：%p\n", &a);  // 输出：00000000005ffe40
```

- `a` 的类型是 `int[5]`（数组类型）
- `&a` 的类型是 `int(*)[5]`（指向整个数组的指针）

```c
#include <stdio.h>

int main() {
    int a[5] = {0,1,2,3,4};
    
    printf("a的地址：%p\n", a);      // 比如: 0x1000
    printf("&a的地址：%p\n", &a);    // 也是: 0x1000
    
    printf("a + 1 的地址：%p\n", a + 1);    // 0x1004 (前进4字节)
    printf("&a + 1 的地址：%p\n", &a + 1);  // 0x1014 (前进20字节)
    
    return 0;
}
```

---

[【重学C++】【指针】详解让人迷茫的指针数组和数组指针-阿里云开发者社区](https://developer.aliyun.com/article/1490468)

https://blog.csdn.net/lirendada/article/details/122931987

https://blog.csdn.net/qq_36812406/article/details/152221020

[c++数组基本用法 - IT老boy - 博客园](https://www.cnblogs.com/itlaoboy/p/17666866.html)

[数组的常用方法（详解） - GeQin - 博客园](https://www.cnblogs.com/geqin/p/6955796.html)