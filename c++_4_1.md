# c++标准库

* 标准函数库

  由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。

* 面向对象类库

  类及其相关函数的集合。

## 输入输出

### \<iostream>：标准输入输出流

`<iostream>`库是 C++ 标准库中用于输入输出操作的头文件。定义了几个常用的流类和操作符，允许程序与标准输入输出设备（如键盘和屏幕）进行交互。

#### 主要类

- `std::istream`：用于输入操作的抽象基类。
- `std::ostream`：用于输出操作的抽象基类。
- `std::iostream`：继承自`std::istream`和`std::ostream`，用于同时进行输入和输出操作。
- `std::cin`：标准输入流对象，通常与键盘关联。
- `std::cout`：标准输出流对象，通常与屏幕关联。
- `std::cerr`：标准错误输出流对象，不带缓冲，通常与屏幕关联。
- `std::clog`：标准日志流对象，带缓冲，通常与屏幕关联。

#### 常用操作符

- `>>`：输入操作符，从输入流读取数据。
- `<<`：输出操作符，将数据写入输出流。

#### 实例

##### 标准输入输出

```c
#include <iostream>

int main() {
  int age;
  std::string name;

  // 使用 std::cout 输出到屏幕
  std::cout << "Enter your name: ";
  // 使用 std::cin 从键盘读取输入
  std::cin >> name;

  std::cout << "Enter your age: ";
  std::cin >> age;

  // 输出读取到的数据
  std::cout << "Hello, " << name << "! You are " << age << " years old." << std::endl;

  return 0;
}
```

##### 标准错误输出

```c
#include <iostream>

int main() {
    std::cerr << "An error occurred!" << std::endl;
    return 0;
}
```

##### 标准日志输出

```c
#include <iostream>

int main() {
  std::clog << "This is a log message." << std::endl;
  return 0;
}
```

##### 格式化输出:

使用`<iomanip>`库可以对输出进行格式化，例如设置宽度、精度和对齐方式。

```c
#include <iostream>
#include <iomanip>

int main() {
  double pi = 3.14159;

  // 设置输出精度
  std::cout << std::setprecision(3) << pi << std::endl;

  // 设置输出宽度和对齐方式
  std::cout << std::setw(10) << std::left << pi << std::endl;
  std::cout << std::setw(10) << std::right << pi << std::endl;

  return 0;
}
```

##### 流的状态检查

可以检查输入输出流的状态，以确定操作是否成功。

```c
#include <iostream>

int main() {
  int num;
  std::cout << "Enter a number: ";
  std::cin >> num;

  // 检查输入操作是否成功
  if (std::cin.fail()) {
    std::cerr << "Invalid input!" << std::endl;
  } else {
    std::cout << "You entered: " << num << std::endl;
  }

  return 0;
}
```

##### 处理字符串输入

使用`std::getline`函数可以读取包含空格的整行输入。

```c
#include <iostream>
#include <string>

int main() {
  std::string fullName;
  std::cout << "Enter your full name: ";
  std::getline(std::cin, fullName);
  std::cout << "Hello, " << fullName << "!" << std::endl;

  return 0;
}
```

### \<fstream>：文件输入输出流

在 C++ 中，` <fstream>` 是标准库中用于文件输入输出操作的类。它提供了一种方便的方式来读写文件。

`fstream`是`iostream`库的一部分，支持文本和二进制文件的读写。

`fstream`类是`iostream`库中的一个类，它继承自`istream`和`ostream`类，这意味着它既可以用于输入也可以用于输出。

#### 语法

`fstream` 的基本语法如下：

```c
#include <fstream>

int main() {
  std::fstream file; // 创建fstream对象
  file.open("filename", mode); // 打开文件
  // 进行文件操作
  file.close(); // 关闭文件
  return 0;
}
```

其中`filename` 是文件的名称，`mode` 是打开文件的模式，常见的模式有：

- `std::ios::in`：以输入模式打开文件。
- `std::ios::out`：以输出模式打开文件。
- `std::ios::app`：以追加模式打开文件。
- `std::ios::ate`：打开文件并定位到文件末尾。
- `std::ios::trunc`：打开文件并截断文件，即清空文件内容。

#### 实例

##### 写入文本文件

```c
#include <fstream>
#include <iostream>

int main() {
  std::fstream file;
  file.open("example.txt", std::ios::out); // 以输出模式打开文件

  if (!file) {
    std::cerr << "Unable to open file!" << std::endl;
    return 1; // 文件打开失败
  }

  file << "Hello, World!" << std::endl; // 写入文本
  file.close(); // 关闭文件

  return 0;
}
```

在当前目录下创建一个名为`example.txt`的文件，文件内容为：

```
Hello, World!
```

##### 读取文本文件

```c
#include <fstream>
#include <iostream>
#include <string>

int main() {
  std::fstream file;
  file.open("example.txt", std::ios::in); // 以输入模式打开文件

  if (!file) {
    std::cerr << "Unable to open file!" << std::endl;
    return 1; // 文件打开失败
  }

  std::string line;
  while (getline(file, line)) { // 逐行读取
    std::cout << line << std::endl;
  }

  file.close(); // 关闭文件

  return 0;
}
```

如果 `example.txt` 文件包含以下内容：

```
Hello, World!
This is a test file.
```

则程序将输出：

```
Hello, World!
This is a test file.
```

##### 追加到文件:

```c
#include <fstream>
#include <iostream>

int main() {
  std::fstream file;
  file.open("example.txt", std::ios::app); // 以追加模式打开文件

  if (!file) {
    std::cerr << "Unable to open file!" << std::endl;
    return 1; // 文件打开失败
  }

  file << "Appending this line to the file." << std::endl; // 追加文本
  file.close(); // 关闭文件

  return 0;
}
```

`example.txt` 文件原本包含以下内容：

```cpp
Hello, World!
This is a test file.
```

执行上述程序后，文件内容将变为：

```cpp
Hello, World!
This is a test file.
Appending this line to the file.
```

### \<sstream>：字符串流

在 C++ 编程中，处理字符串和数字之间的转换是一项常见的任务。

`sstream` 是 C++ 标准库中的一个组件，它提供了一种方便的方式来处理字符串流（可以像处理流一样处理字符串）。

`<sstream>` 允许你将字符串当作输入/输出流来使用，这使得从字符串中读取数据或将数据写入字符串变得非常简单。

#### 定义

`sstream`是 C++ 标准库中的一个命名空间，它包含了几个类，用于处理字符串流，这些类包括：

- `istringstream`：用于从字符串中读取数据。
- `ostringstream`：用于将数据写入字符串。
- `stringstream`：是`istringstream`和`ostringstream`的组合，可以同时进行读取和写入操作。

#### 语法

使用`sstream`的基本语法如下：

```cpp
#include <sstream>

// 使用istringstream
std::istringstream iss("some data");

// 使用ostringstream
std::ostringstream oss;

// 使用stringstream
std::stringstream ss;
```

#### 实例

##### 从字符串读取数据

下面是一个使用 `istringstream` 从字符串中读取整数和浮点数的例子：

```c
#include <iostream>
#include <sstream>

int main() {
  std::string data = "10 20.5";
  std::istringstream iss(data);

  int i;
  double d;

  iss >> i >> d;

  std::cout << "Integer: " << i << std::endl;
  std::cout << "Double: " << d << std::endl;

  return 0;
}
```

输出结果：

```
Integer: 10
Double: 20.5
```

##### 向字符串写入数据

下面是一个使用 `ostringstream` 将数据写入字符串的例子：

```c
#include <iostream>
#include <sstream>

int main() {
  std::ostringstream oss;
  int i = 100;
  double d = 200.5;

  oss << i << " " << d;

  std::string result = oss.str();
  std::cout << "Resulting string: " << result << std::endl;

  return 0;
}
```

输出结果：

```
Resulting string: 100 200.5
```

##### 使用stringstream进行读写操作

下面是一个使用 `stringstream` 同时进行读取和写入操作的例子：

```c
#include <iostream>
#include <sstream>

int main() {
  std::string data = "30 40.5";
  std::stringstream ss(data);

  int i;
  double d;

  // 从stringstream读取数据
  ss >> i >> d;

  std::cout << "Read Integer: " << i << ", Double: " << d << std::endl;

  // 向stringstream写入数据
  ss.str(""); // 清空stringstream
  ss << "New data: " << 50 << " " << 60.7;

  std::string newData = ss.str();
  std::cout << "New data string: " << newData << std::endl;

  return 0;
}
```

输出结果：

```
Read Integer: 30, Double: 40.5
New data string: New data: 50 60.7
```

总结

`sstream` 是 C++ 标准库中一个非常有用的组件，它简化了字符串和基本数据类型之间的转换。通过上述实例，我们可以看到如何使用 `istringstream`、`ostringstream` 和 `stringstream` 来实现这些转换。掌握这些技能将帮助你在 C++ 编程中更加高效地处理字符串数据。

### \<iomanip>：输入输出流格式化

`<iomanip>` 是 C++ 标准库中的一个头文件，它提供了对输入/输出流的格式化操作。

`iomanip` 库中的函数允许开发者控制输出格式，如设置小数点后的位数、设置宽度、对齐方式等。

`iomanip` 是 Input/Output Manipulators 的缩写，它提供了一组操作符，用于控制 C++ 标准库中的输入/输出流的格式，适用以下场景：

- 科学计算中浮点数格式的处理；
- 数据对齐与美化；
- 显示特定进制或格式的数值。

#### 语法

`iomanip` 库中的函数通常与 `<<` 和 `>>` 操作符一起使用，以实现对输出流的控制。

以下是一些常用的 `iomanip` 函数：

| **函数/操纵符**              | **功能**                               | **实例代码**                                                 | **输出结果**   |
| :--------------------------- | :------------------------------------- | :----------------------------------------------------------- | :------------- |
| `std::setw(int n)`           | **设置字段宽度，为下一次输出指定宽度** | `std::cout << std::setw(5) << 42;`                           | `42`           |
| `std::setfill(char)`         | **设置填充字符（默认是空格）**         | `std::cout << std::setfill('*') << std::setw(5) << 42;`      | `***42`        |
| `std::left`                  | 设置左对齐                             | `std::cout << std::left << std::setw(5) << 42;`              | `42`           |
| `std::right`                 | 设置右对齐                             | `std::cout << std::right << std::setw(5) << 42;`             | `42`           |
| `std::internal`              | 符号靠左，其余靠右                     | `std::cout << std::internal << std::setw(5) << -42;`         | `- 42`         |
| `std::setprecision(int)**`** | **设置浮点数的有效位数**               | `std::cout << std::setprecision(3) << 3.14159;`              | `3.14`         |
| `std::fixed**`**             | **设置定点格式输出浮点数**             | `std::cout << std::fixed << std::setprecision(2) << 3.14159;` | `3.14`         |
| `std::scientific`            | **设置科学计数法格式输出浮点数**       | `std::cout << std::scientific << 3.14159;`                   | `3.141590e+00` |
| `std::hex`                   | 设置整数以 16 进制显示                 | `std::cout << std::hex << 42;`                               | `2a`           |
| `std::oct`                   | 设置整数以 8 进制显示                  | `std::cout << std::oct << 42;`                               | `52`           |
| `std::dec`                   | 设置整数以 10 进制显示（默认）         | `std::cout << std::dec << 42;`                               | `42`           |
| `std::showbase`              | 显示进制前缀（如 `0x` 表示 16 进制）   | `std::cout << std::showbase << std::hex << 42;`              | `0x2a`         |
| `std::noshowbase`            | 隐藏进制前缀（默认）                   | `std::cout << std::noshowbase << std::hex << 42;`            | `2a`           |
| `std::uppercase`             | 16 进制字母显示为大写                  | `std::cout << std::uppercase << std::hex << 42;`             | `2A`           |
| `std::nouppercase`           | 16 进制字母显示为小写（默认）          | `std::cout << std::nouppercase << std::hex << 42;`           | `2a`           |
| `std::showpos`               | 在正数前显示 `+` 符号                  | `std::cout << std::showpos << 42;`                           | `+42`          |
| `std::noshowpos`             | 不显示正数的 `+` 符号（默认）          | `std::cout << std::noshowpos << 42;`                         | `42`           |
| `std::boolalpha`             | 布尔值以 `true/false` 输出             | `std::cout << std::boolalpha << true;`                       | `true`         |
| `std::noboolalpha`           | 布尔值以 `1/0` 输出（默认）            | `std::cout << std::noboolalpha << true;`                     | `1`            |
| `std::setbase(int n)`        | 设置整数的进制（支持 8、10、16）       | `std::cout << std::setbase(16) << 42;`                       | `2a`           |
| `std::resetiosflags`         | **重置指定的流状态**                   | `std::cout << std::resetiosflags(std::ios::showbase) << std::hex << 42;` | `2a`           |
| `std::setiosflags`           | **设置指定的流状态**                   | `std::cout << std::setiosflags(std::ios::showbase) << std::hex << 42;` | `0x2a`         |

## 容器

### \<array>: 定长数组容器

C++11 标准引入了 `<array>` 头文件，它提供了一种固定大小的数组容器，与 C 语言中的数组相比，具有更好的类型安全和内存管理特性。

`std::array` 是 C++ 标准库中的一个模板类，它定义在 `<array>` 头文件中。`std::array` 模板类提供了一个固定大小的数组，其大小在编译时确定，并且不允许动态改变。

#### 语法

`std::array` 的基本语法如下：

```cpp
#include <array>
std::array<T, N> array_name;
```

- `T` 是数组中元素的类型。
- `N` 是数组的大小，必须是一个非负整数。

#### 声明与初始化

`<array>` 需要在编译时确定大小，不能动态改变。使用示例：

```cpp
#include <iostream>
#include <array>
int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5}; // 声明一个定长为5的int数组
    return 0;
}
```

#### 特点

- **类型安全**：`std::array` 强制类型检查，避免了 C 语言数组的类型不安全问题。
- **固定大小**：数组的大小在编译时确定，不能在运行时改变。
- **内存连续**：`std::array` 的元素在内存中是连续存储的，这使得它可以高效地访问元素。
- **标准容器**：`std::array` 提供了与 `std::vector` 类似的接口，如 `size()`, `at()`, `front()`, `back()` 等。

#### 实例

下面是一个使用 `std::array` 的简单示例，包括输出结果。

```c
#include <iostream>
#include <array>

int main() {
  // 创建一个包含 5 个整数的 std::array
  std::array<int, 5> myArray = {1, 2, 3, 4, 5};

  // 使用范围 for 循环遍历数组
  for (const auto& value : myArray) {
    std::cout << value << " ";
  }
  std::cout << std::endl;

  // 使用索引访问数组元素
  std::cout << "Element at index 2: " << myArray.at(2) << std::endl;

  // 获取数组的大小
  std::cout << "Array size: " << myArray.size() << std::endl;

  // 修改数组元素
  myArray[3] = 10;

  // 再次遍历数组以显示修改后的元素
  for (const auto& value : myArray) {
    std::cout << value << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

输出结果:

```c
1 2 3 4 5 
Element at index 2: 3
Array size: 5
1 2 3 10 5 
```

#### 常用成员函数

| 函数                   | 说明                             |
| :--------------------- | :------------------------------- |
| `at(size_t pos)`       | 返回指定位置的元素，带边界检查   |
| `operator[]`           | 返回指定位置的元素，不带边界检查 |
| `front()`              | 返回数组的第一个元素             |
| `back()`               | 返回数组的最后一个元素           |
| `data()`               | 返回指向数组数据的指针           |
| `size()`               | 返回数组大小（固定不变）         |
| `fill(const T& value)` | 将数组所有元素设置为指定值       |
| `swap(array& other)`   | 交换两个数组的内容               |
| `begin()` / `end()`    | 返回数组的起始/结束迭代器        |

**使用 at 和边界检查**

```c
#include <iostream>
#include <array>

int main() {
  std::array<int, 3> arr = {1, 2, 3};

  try {
    std::cout << arr.at(2) << std::endl; // 正常输出
    std::cout << arr.at(5) << std::endl; // 超出范围，抛出异常
  } catch (const std::out_of_range& e) {
    std::cout << "Exception: " << e.what() << std::endl;
  }

  return 0;
}
```

#### 与其他数组类型对比

| 特性         | `std::array`        | C 风格数组          | `std::vector`       |
| :----------- | :------------------ | :------------------ | :------------------ |
| **大小**     | 编译时固定          | 编译时固定          | 动态可变            |
| **边界检查** | `at()` 提供边界检查 | 无                  | `at()` 提供边界检查 |
| **内存管理** | 栈上分配            | 栈上分配            | 堆上分配            |
| **性能**     | 高效                | 高效                | 较低（动态分配）    |
| **接口**     | 支持 STL 标准接口   | 不支持 STL 标准接口 | 支持 STL 标准接口   |

### \<vector>: 动态数组容器

C++ 标准库（Standard Template Library, STL）是 C++ 的一个重要组成部分，它提供了一组通用的模板类和函数，用于处理数据集合。`<vector>` 是 STL 中的一个容器类，用于存储动态大小的数组。

`<vector>` 是一个序列容器，它允许用户在容器的末尾快速地添加或删除元素。与数组相比，`<vector>` 提供了更多的功能，如自动调整大小、随机访问等。

#### 语法

- 声明一个 `vector`：

  ```c
  std::vector<int> myVector;
  ```

- 添加元素：

  ```c
  myVector.push_back(10);
  ```

- 访问元素：

  ```c
  int firstElement = myVector[0];
  ```

- 获取元素数量：

  ```c
  size_t size = myVector.size();
  ```

- 清空 `vector`：

  ```c
  myVector.clear();
  ```

#### 声明与初始化

`<vector>` 需要指定元素类型，可通过多种方式进行初始化：

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec1;                  // 空的vector
    std::vector<int> vec2(5);               // 长度为5的vector，元素默认初始化
    std::vector<int> vec3(5, 10);           // 长度为5的vector，元素值为10
    std::vector<int> vec4 = {1, 2, 3, 4};   // 使用初始化列表初始化

    return 0;
}
```

#### 常用成员函数

| 函数                        | 说明                             |
| :-------------------------- | :------------------------------- |
| `push_back(const T& val)`   | 在末尾添加元素                   |
| `pop_back()`                | 删除末尾元素                     |
| `at(size_t pos)`            | 返回指定位置的元素，带边界检查   |
| `operator[]`                | 返回指定位置的元素，不带边界检查 |
| `front()`                   | 返回第一个元素                   |
| `back()`                    | 返回最后一个元素                 |
| `data()`                    | 返回指向底层数组的指针           |
| `size()`                    | 返回当前元素数量                 |
| `capacity()`                | 返回当前分配的容量               |
| `reserve(size_t n)`         | 预留至少 `n` 个元素的存储空间    |
| `resize(size_t n)`          | 将元素数量调整为 `n`             |
| `clear()`                   | 清空所有元素                     |
| `insert(iterator pos, val)` | 在指定位置插入元素               |
| `erase(iterator pos)`       | 删除指定位置的元素               |
| `begin()` / `end()`         | 返回起始/结束迭代器              |

**边界检查和安全访问**

```c
#include <iostream>
#include <vector>

int main() {
  std::vector<int> vec = {1, 2, 3};

  try {
    std::cout << vec.at(2) << std::endl; // 正常输出
    std::cout << vec.at(5) << std::endl; // 超出范围，抛出异常
  } catch (const std::out_of_range& e) {
    std::cout << "Exception: " << e.what() << std::endl;
  }

  return 0;
}
```

**预分配容量**

```c
#include <iostream>
#include <vector>

int main() {
  std::vector<int> vec;
  vec.reserve(10); // 预留容量，避免频繁分配内存

  for (int i = 0; i < 10; ++i) {
    vec.push_back(i);
    std::cout << "Capacity after push_back(" << i << "): " << vec.capacity() << std::endl;
  }

  return 0;
}
```

#### 与其他容器对比

| 特性               | `std::vector`                | `std::array` | `std::list`              |
| :----------------- | :--------------------------- | :----------- | :----------------------- |
| **大小**           | 动态可变                     | 编译时固定   | 动态可变                 |
| **存储位置**       | 连续内存                     | 连续内存     | 非连续内存               |
| **访问性能**       | 随机访问快速                 | 随机访问快速 | 随机访问慢，适合顺序访问 |
| **插入和删除性能** | 末尾操作性能高，其他位置较慢 | 不支持       | 任意位置插入和删除较快   |
| **内存增长方式**   | 容量不足时成倍增长           | 无           | 无                       |

### \<list>： 双向链表容器

C++ 标准库提供了丰富的功能，其中 `<list>` 是一个非常重要的容器类，用于存储元素集合，支持双向迭代器。

`<list>` 是 C++ 标准模板库（STL）中的一个序列容器，它允许在容器的任意位置快速插入和删除元素。与数组或向量（`<vector>`）不同，`<list>` 不需要在创建时指定大小，并且可以在任何位置添加或删除元素，而不需要重新分配内存。

#### 语法

以下是 `<list>` 容器的一些基本操作：

- 包含头文件：`#include <list>`
- 声明列表：`std::list<T> mylist;`，其中 `T` 是存储在列表中的元素类型。
- 插入元素：`mylist.push_back(value);`
- 删除元素：`mylist.pop_back();` 或 `mylist.erase(iterator);`
- 访问元素：`mylist.front();` 和 `mylist.back();`
- 遍历列表：使用迭代器 `for (auto it = mylist.begin(); it != mylist.end(); ++it)`

#### 特点

- **双向迭代**：`<list>` 提供了双向迭代器，可以向前和向后遍历元素。
- **动态大小**：与数组不同，`<list>` 的大小可以动态变化，不需要预先分配固定大小的内存。
- **快速插入和删除**：可以在列表的任何位置快速插入或删除元素，而不需要像向量那样移动大量元素。

#### 声明与初始化

`<list>` 的声明和初始化与其他容器类似：

```c
#include <iostream>
#include <list>

int main() {
    std::list<int> lst1;                  // 空的list
    std::list<int> lst2(5);               // 包含5个默认初始化元素的list
    std::list<int> lst3(5, 10);           // 包含5个元素，每个元素为10
    std::list<int> lst4 = {1, 2, 3, 4};   // 使用初始化列表

    return 0;
}
```

#### 常用成员函数：

| 函数                        | 说明                      |
| :-------------------------- | :------------------------ |
| `push_back(const T& val)`   | 在链表末尾添加元素        |
| `push_front(const T& val)`  | 在链表头部添加元素        |
| `pop_back()`                | 删除链表末尾的元素        |
| `pop_front()`               | 删除链表头部的元素        |
| `insert(iterator pos, val)` | 在指定位置插入元素        |
| `erase(iterator pos)`       | 删除指定位置的元素        |
| `clear()`                   | 清空所有元素              |
| `size()`                    | 返回链表中的元素数量      |
| `empty()`                   | 检查链表是否为空          |
| `front()`                   | 返回链表第一个元素        |
| `back()`                    | 返回链表最后一个元素      |
| `remove(const T& val)`      | 删除所有等于指定值的元素  |
| `sort()`                    | 对链表中的元素进行排序    |
| `merge(list& other)`        | 合并另一个已排序的链表    |
| `reverse()`                 | 反转链表                  |
| `begin()` / `end()`         | 返回链表的起始/结束迭代器 |

#### 与其他容器对比

| 特性              | `std::list`                  | `std::vector`                | `std::deque`                 |
| :---------------- | :--------------------------- | :--------------------------- | :--------------------------- |
| **内存结构**      | 非连续内存，双向链表         | 连续内存                     | 分段连续内存                 |
| **访问性能**      | 顺序访问较快，随机访问慢     | 随机访问快                   | 末尾和头部访问都快           |
| **插入/删除性能** | 任意位置插入、删除快         | 末尾插入快，中间位置慢       | 头尾插入、删除快             |
| **适用场景**      | 频繁在中间插入/删除          | 需要高效随机访问             | 需要在头尾快速插入/删除      |
| **迭代器稳定性**  | 稳定，元素插入或删除不会失效 | 插入、删除可能导致迭代器失效 | 插入、删除可能导致迭代器失效 |

#### 注意事项

- `<list>` 的元素是按插入顺序存储的，而不是按元素值排序。
- 由于 `<list>` 的元素存储在不同的内存位置，所以它不适合需要随机访问的场景。
- 与向量相比，`<list>` 的内存使用效率较低，因为每个元素都需要额外的空间来存储指向前后元素的指针。

### \<forward_list>： 单向链表容器

C++ 标准库中的 `<forward_list>` 是一种容器，它提供了一种单向链表的数据结构。

与双向链表（`std::list`）不同，`std::forward_list` 只支持单向遍历。它适用于需要频繁进行前向遍历和插入、删除操作的场景。以下是对 `std::forward_list` 的详细说明：

**单向链表**：

- `std::forward_list` 是单向链表，只能从前往后遍历，不能反向遍历。
- 由于其单向链表的结构，插入和删除操作在已知位置的情况下非常高效（O(1) 复杂度）。

**低内存开销**：

- 与 `std::list` 相比，`std::forward_list` 只需要一个指向下一个节点的指针，节省了内存。

**不支持随机访问**：

- 不支持通过索引访问元素，不能使用 `operator[]` 或 `at` 方法，只能通过迭代器进行访问。

#### 语法

`std::forward_list` 是 C++ 标准库中的一个模板类，定义在 `<forward_list>` 头文件中。它使用模板参数 `T` 来指定存储在列表中的元素类型。

以下是 `std::forward_list` 的基本语法：

```
#include <forward_list>

std::forward_list<T> list;
```

#### 构造函数

`std::forward_list` 提供了多种构造函数，包括：

- 默认构造函数：创建一个空的 `forward_list`。
- 带初始值的构造函数：创建一个包含给定初始值的 `forward_list`。
- 带范围的构造函数：创建一个包含指定范围内元素的 `forward_list`。

#### 常用成员函数

- `void push_front(const T& value)`：在列表的前端插入一个元素。
- `void pop_front()`：移除列表前端的元素。
- `iterator before_begin()`：返回指向列表前端之前的迭代器。
- `iterator begin()`：返回指向列表前端的迭代器。
- `iterator end()`：返回指向列表末尾的迭代器

### \<deque>： 双端队列容器

在 C++中，`<deque>` 是标准模板库（STL）的一部分，它提供了双端队列（double-ended queue）的实现。

双端队列是一种允许在两端进行插入和删除操作的线性数据结构。

`<deque>` 的全称是 "double-ended queue"，它在C++中以模板类的形式存在，允许存储任意类型的数据。

`<deque>` 是一个动态数组，它提供了快速的随机访问能力，同时允许在两端进行高效的插入和删除操作。这使得 `<deque>` 成为处理需要频繁插入和删除元素的场景的理想选择。

#### 语法

在 C++ 中，使用 `<deque>` 需要包含头文件 `#include <deque>`。以下是 `<deque>` 的基本语法：

```c
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque; // 创建一个整数类型的双端队列
    // 接下来可以进行插入、删除等操作
    return 0;
}
```

####  常用操作

| 函数名称                               | 功能描述                                          |
| :------------------------------------- | :------------------------------------------------ |
| `deque()`                              | 默认构造函数，创建一个空的 `deque` 容器。         |
| `deque(size_type n)`                   | 创建一个包含 `n` 个默认值元素的 `deque` 容器。    |
| `deque(size_type n, const T& value)`   | 创建一个包含 `n` 个值为 `value` 的 `deque` 容器。 |
| `deque(initializer_list<T> il)`        | 使用初始化列表 `il` 构造 `deque` 容器。           |
| `operator=`                            | 赋值操作符，赋值给 `deque` 容器。                 |
| `assign()`                             | 用新值替换 `deque` 容器中的所有元素。             |
| `at(size_type pos)`                    | 返回 `pos` 位置的元素，并进行范围检查。           |
| `operator[](size_type pos)`            | 返回 `pos` 位置的元素，不进行范围检查。           |
| `front()`                              | 返回第一个元素的引用。                            |
| `back()`                               | 返回最后一个元素的引用。                          |
| `begin()`                              | 返回指向第一个元素的迭代器。                      |
| `end()`                                | 返回指向末尾元素后一位置的迭代器。                |
| `rbegin()`                             | 返回指向最后一个元素的逆向迭代器。                |
| `rend()`                               | 返回指向第一个元素之前位置的逆向迭代器。          |
| `empty()`                              | 检查容器是否为空。                                |
| `size()`                               | 返回容器中的元素个数。                            |
| `max_size()`                           | 返回容器可容纳的最大元素个数。                    |
| `clear()`                              | 清除容器中的所有元素。                            |
| `insert(iterator pos, const T& value)` | 在 `pos` 位置插入 `value` 元素。                  |
| `erase(iterator pos)`                  | 移除 `pos` 位置的元素。                           |
| `push_back(const T& value)`            | 在容器末尾添加 `value` 元素。                     |
| `pop_back()`                           | 移除容器末尾的元素。                              |
| `push_front(const T& value)`           | 在容器前端添加 `value` 元素。                     |
| `pop_front()`                          | 移除容器前端的元素。                              |
| `resize(size_type count)`              | 调整容器大小为 `count`，多出部分用默认值填充。    |
| `swap(deque& other)`                   | 交换两个 `deque` 容器的内容。                     |
| `get_allocator()`                      | 返回一个用于构造双端队列的分配器对象的副本。      |

**注意：**在使用 front() 或 back() 之前，确保双端队列不为空，否则会引发未定义的行为。如果需要检查双端队列是否为空，可以使用 empty() 成员函数。

### \<stack>： 栈容器适配器

在 C++ 中，标准库提供了多种容器和算法来帮助开发者更高效地编写程序。

`<stack>` 是 C++ 标准模板库（STL）的一部分，它实现了一个后进先出（LIFO，Last In First Out）的数据结构。这种数据结构非常适合于需要"最后添加的元素最先被移除"的场景。

`<stack>` 容器适配器提供了一个栈的接口，它基于其他容器（如 `deque` 或 `vector`）来实现。栈的元素是线性排列的，但只允许在一端（栈顶）进行添加和移除操作。

#### 基本操作

- `push()`: 在栈顶添加一个元素。
- `pop()`: 移除栈顶元素。
- `top()`: 返回栈顶元素的引用，但不移除它。
- `empty()`: 检查栈是否为空。
- `size()`: 返回栈中元素的数量。

#### 注意事项

- `<stack>` 不提供直接访问栈中元素的方法，只能通过 `top()` 访问栈顶元素。
- 尝试在空栈上调用 `top()` 或 `pop()` 将导致未定义行为。
- `<stack>` 的底层容器可以是任何支持随机访问迭代器的序列容器，如 `vector` 或 `deque`。

### \<queue>： 队列容器适配器

C++ 标准库中的 `<queue>` 头文件提供了队列（Queue）数据结构的实现。队列是一种先进先出（FIFO, First In First Out）的数据结构，它允许在一端添加元素（称为队尾），并在另一端移除元素（称为队首）。

队列是一种线性数据结构，它遵循以下规则：

- 元素只能从队尾添加。
- 元素只能从队首移除。

#### 基本操作

队列提供了以下常用操作：

- `empty()`: 检查队列是否为空。
- `size()`: 返回队列中的元素数量。
- `front()`: 返回队首元素的引用。
- `back()`: 返回队尾元素的引用。
- `push()`: 在队尾添加一个元素。
- `pop()`: 移除队首元素。

#### 注意事项

- 队列不允许随机访问元素，即不能直接通过索引访问队列中的元素。
- 队列的实现通常使用链表或动态数组，这取决于具体的实现。

### \<priority_queue>： 优先队列容器适配器

在 C++ 中，`<priority_queue>` 是标准模板库（STL）的一部分，用于实现优先队列。

优先队列是一种特殊的队列，它允许我们快速访问队列中具有最高（或最低）优先级的元素。

在 C++ 中，`priority_queue` 默认是一个最大堆，这意味着队列的顶部元素总是具有最大的值。

`priority_queue` 是一个容器适配器，它提供了对底层容器的堆操作。它不提供迭代器，也不支持随机访问。

#### 语法

以下是 `priority_queue` 的基本语法：

```c
#include <queue>

// 声明一个整型优先队列
priority_queue<int> pq;

// 声明一个自定义类型的优先队列，需要提供比较函数
struct compare {
    bool operator()(int a, int b) {
        return a > b; // 这里定义了最小堆
    }
};
priority_queue<int, vector<int>, compare> pq_min;
```

####c常用操作

- `empty()`: 检查队列是否为空。
- `size()`: 返回队列中的元素数量。
- `top()`: 返回队列顶部的元素（不删除它）。
- `push()`: 向队列添加一个元素。
- `pop()`: 移除队列顶部的元素。

#### c实例

下面是一个使用 `priority_queue` 的简单实例，我们将创建一个最大堆，并展示如何添加元素和获取队列顶部的元素。

```c
#include <iostream>
#include <queue>

int main() {
  // 创建一个整型优先队列
  std::priority_queue<int> pq;

  // 向优先队列中添加元素
  pq.push(30);
  pq.push(10);
  pq.push(50);
  pq.push(20);

  // 输出队列中的元素
  std::cout << "队列中的元素：" << std::endl;
  while (!pq.empty()) {
    std::cout << pq.top() << std::endl;
    pq.pop();
  }

  return 0;
}
```

输出结果：

```c
队列中的元素：
50
30
20
10
```

#### 自定义优先级

如果需要一个最小堆，可以通过自定义比较函数来实现：

```c
#include <iostream>
#include <queue>
#include <vector>

struct compare {
  bool operator()(int a, int b) {
    return a > b; // 定义最小堆
  }
};

int main() {
  // 创建一个自定义类型的优先队列，使用最小堆
  std::priority_queue<int, std::vector<int>, compare> pq_min;

  // 向优先队列中添加元素
  pq_min.push(30);
  pq_min.push(10);
  pq_min.push(50);
  pq_min.push(20);

  // 输出队列中的元素
  std::cout << "最小堆中的元素：" << std::endl;
  while (!pq_min.empty()) {
    std::cout << pq_min.top() << std::endl;
    pq_min.pop();
  }

  return 0;
}
```

输出结果：

```
最小堆中的元素：
10
20
30
50
```

`<priority_queue>` 是C++ STL中一个非常有用的容器，特别适合需要快速访问最高或最低优先级元素的场景。通过自定义比较函数，我们可以轻松地实现最大堆或最小堆。希望这篇文章能帮助初学者更好地理解和使用 `priority_queue`。

### <set\>： 集合容器（基于平衡二叉树

C++ 标准库中的 `<set>` 是一个关联容器，它存储了一组唯一的元素，并按照一定的顺序进行排序。

`<set>` 提供了高效的元素查找、插入和删除操作。它是基于红黑树实现的，因此具有对数时间复杂度的查找、插入和删除性能。

`<set>` 容器中存储的元素类型必须满足以下条件：

- 元素类型必须可以比较大小。
- 元素类型必须可以被复制和赋值。

#### 语法

包含头文件:

```
#include <set>
```

声明 set 容器

```
std::set<元素类型> 容器名;
```

#### 常用操作

- `insert(元素)`: 插入一个元素。
- `erase(元素)`: 删除一个元素。
- `find(元素)`: 查找一个元素。
- `size()`: 返回容器中元素的数量。
- `empty()`: 检查容器是否为空。

### \<unordered_set>： 无序集合容器（基于哈希表）

在C++中，`<unordered_set>` 是标准模板库（STL）的一部分，提供了一种基于哈希表的容器，用于存储唯一的元素集合。

与 `set` 不同，`unordered_set` 不保证元素的排序，但通常提供更快的查找、插入和删除操作。

`unordered_set` 是一个模板类，其定义如下：

```c
#include <unordered_set>

std::unordered_set<Key, Hash = std::hash<Key>, Pred = std::equal_to<Key>, Alloc = std::allocator<Key>>
```

- `Key` 是存储在 `unordered_set` 中的元素类型。
- `Hash` 是一个函数或函数对象，用于生成元素的哈希值，默认为 `std::hash<Key>`。
- `Pred` 是一个二元谓词，用于比较两个元素是否相等，默认为 `std::equal_to<Key>`。
- `Alloc` 是分配器类型，用于管理内存分配，默认为 `std::allocator<Key>`。

#### 语法

- **构造函数**：创建一个空的 `unordered_set`。

  ```c
  std::unordered_set<int> uset;
  ```

- **插入元素**：使用 `insert()` 方法。

  ```c
  uset.insert(10);
  ```

- **查找元素**：使用 `find()` 方法。

  ```c
  auto it = uset.find(10);
  if (it != uset.end()) {
    // 元素存在
  }
  ```

- **删除元素**：使用 `erase()` 方法。

  ```c
  uset.erase(10);
  ```

- **大小和空检查**：使用 `size()` 和 `empty()` 方法。

  ```c
  size_t size = uset.size();
  bool isEmpty = uset.empty();
  ```

- **清空容器**：使用 `clear()` 方法。

  ```c
  uset.clear();
  ```

### \<map>： 映射容器（键值对，基于平衡二叉树）

在 C++ 中，`<map>` 是标准模板库（STL）的一部分，它提供了一种关联容器，用于存储键值对（key-value pairs）。

`map` 容器中的元素是按照键的顺序自动排序的，这使得它非常适合需要快速查找和有序数据的场景。

#### 定义和特性

- **键值对**：`map` 存储的是键值对，其中每个键都是唯一的。
- **排序**：`map` 中的元素按照键的顺序自动排序，通常是升序。
- **唯一性**：每个键在 `map` 中只能出现一次。
- **双向迭代器**：`map` 提供了双向迭代器，可以向前和向后遍历元素。

#### 基本语法

包含头文件:

```c
#include <map>
```

声明 map 容器:

```c
std::map<key_type, value_type> myMap;
```

- `key_type` 是键的类型。
- `value_type` 是值的类型。

插入元素:

```c
myMap[key] = value;
```

访问元素:

```c
value = myMap[key];
```

遍历 map:

```c
for (std::map<key_type, value_type>::iterator it = myMap.begin(); it != myMap.end(); ++it) {
    std::cout << it->first << " => " << it->second << std::endl;
}
```

C++11 及以上标准，遍历部分可以简化为范围 for 循环，代码更简洁：

```c
for (auto &p : m) {
    std::cout << p.first << " : " << p.second << std::endl;
}
```

#### 进阶用法

检查键是否存在:

```c
if (myMap.find(key) != myMap.end()) {
    // 键存在
}
```

删除元素:

```c
myMap.erase(key);
```

清空 map:

```c
myMap.clear();
```

获取 map 的大小:

```c
size_t size = myMap.size();
```

其他方法：

```c
myMap.empty();      // 是否为空
myMap.count("Bob"); // key 是否存在（返回 0 或 1）
```

自定义排序，默认升序排序，可以用 std::greater 或自定义比较函数：

```c
std::map<int, std::string, std::greater<int>> m;  // 降序
```

使用自定义比较函数:

```c
#include <map>
#include <string>
#include <functional>

bool myCompare(const std::string& a, const std::string& b) {
  return a < b;
}

int main() {
  std::map<std::string, int, std::function<bool(const std::string&, const std::string&)>> myMap(myCompare);

  // 其他操作...

  return 0;
```



### \<unordered_map>： 无序映射容器（基于哈希表）

在 C++ 中，`<unordered_map>` 是标准模板库（STL）的一部分，提供了一种基于哈希表的键值对容器。

与 `std::map` 不同，`unordered_map` 不保证元素的排序，但通常提供更快的查找速度。

`unordered_map` 是一个关联容器，它存储了键值对（key-value pairs），其中每个键（key）都是唯一的。`unordered_map` 使用哈希表来存储元素，这使得它在查找、插入和删除操作中具有平均常数时间复杂度。

#### 语法

以下是 `unordered_map` 的基本语法：

```
#include <unordered_map>

std::unordered_map<key_type, value_type> map_name;
```

- `key_type` 是键的类型。
- `value_type` 是值的类型。

#### 构造函数

`unordered_map` 可以以多种方式构造：

```
// 默认构造
std::unordered_map<int, std::string> myMap;

// 构造并初始化
std::unordered_map<int, std::string> myMap = {{1, "one"}, {2, "two"}};

// 构造并指定初始容量
std::unordered_map<int, std::string> myMap(10);

// 构造并复制另一个 unordered_map
std::unordered_map<int, std::string> anotherMap = myMap;
```

#### 基本操作

插入元素:

```c
myMap.insert({3, "three"});
```

访问元素:

```c
std::string value = myMap[1]; // 获取键为1的值
```

删除元素:

```c
myMap.erase(1); // 删除键为1的元素
```

查找元素:

```c
auto it = myMap.find(2); // 查找键为2的元素
if (it != myMap.end()) {
    std::cout << "Found: " << it->second << std::endl;
}
```

#### 注意事项

- `unordered_map` 不保证元素的顺序，因此元素的迭代顺序可能在不同的运行中不同。
- 哈希表的性能依赖于良好的哈希函数，以避免过多的哈希冲突。
- 与 `std::map` 相比，`unordered_map` 在元素数量较少时可能占用更多的内存。

### \<bitset>： 二进制位容器

在 C++ 编程中，`<bitset>` 是标准库的一部分，它提供了一种方式来操作固定大小的位集合。

位集合是一个由位（bit）组成的数组，每个位可以是 0 或 1。

`<bitset>` 提供了一种高效的方式来存储和操作二进制数据，特别适合需要位级操作的场景，如标志位管理、位掩码操作等。

`bitset` 是一个模板类，其模板参数定义了位集合的大小。例如，`bitset<32>` 表示一个包含 32 位的位集合。

#### 语法

以下是使用 `bitset` 的基本语法：

```c
#include <bitset>

// 声明一个大小为N的bitset
std::bitset<N> b;

// 初始化bitset
b = std::bitset<N>(value);

// 访问位集合中的单个位
bool bit = b[i];
```

#### std::bitset 的基本用法

std::bitset 是一个模板类，用于表示固定大小的二进制位序列。它的模板参数是位数（N），表示二进制序列的长度。

定义 std::bitset：

```c
std::bitset<8> bits;  // 定义一个 8 位的二进制序列
```

###### 初始化 std::bitset：

- 默认初始化：所有位为 `0`。
- 从整数初始化：将整数转换为二进制。
- 从字符串初始化：将字符串解析为二进制。

```c
std::bitset<8> bits1;               // 默认初始化：00000000
std::bitset<8> bits2(42);           // 从整数初始化：00101010
std::bitset<8> bits3("10101010");   // 从字符串初始化：10101010
```

#### 常用成员函数

std::bitset 提供了丰富的成员函数来操作二进制位。

###### 访问和修改位:

- `operator[]`：访问或修改某一位。
- `set()`：将某一位或所有位设置为 `1`。
- `reset()`：将某一位或所有位设置为 `0`。
- `flip()`：翻转某一位或所有位。

```c
std::bitset<8> bits("00001111");
bits[0] = 1;          // 修改第 0 位：00001111 -> 00001111
bits.set(4);          // 设置第 4 位：00001111 -> 00011111
bits.reset(1);        // 重置第 1 位：00011111 -> 00011101
bits.flip();          // 翻转所有位：00011101 -> 11100010
```

###### 查询位信息:

- `count()`：返回 `1` 的个数。
- `size()`：返回位数。
- `test(pos)`：检查某一位是否为 `1`。
- `all()`：检查是否所有位都为 `1`。
- `any()`：检查是否有任何一位为 `1`。
- `none()`：检查是否所有位都为 `0`。

```c
std::bitset<8> bits("10101010");
std::cout << "Count of 1s: " << bits.count() << std::endl;  // 输出 4
std::cout << "Size: " << bits.size() << std::endl;          // 输出 8
std::cout << "Is bit 3 set? " << bits.test(3) << std::endl; // 输出 1 (true)
std::cout << "All bits set? " << bits.all() << std::endl;   // 输出 0 (false)
```

###### 转换为其他类型:

- `to_ulong()`：将 `std::bitset` 转换为 `unsigned long`。
- `to_ullong()`：将 `std::bitset` 转换为 `unsigned long long`。
- `to_string()`：将 `std::bitset` 转换为字符串。

```c
std::bitset<8> bits("10101010");
unsigned long num = bits.to_ulong();  // 转换为整数：170
std::string str = bits.to_string();   // 转换为字符串："10101010"
```

###### 位操作

std::bitset 支持常见的位操作，如按位与、按位或、按位异或和按位取反。

- `&`：按位与
- `|`：按位或
- `^`：按位异或
- `~`：按位取反

```c
std::bitset<8> bits1("10101010");
std::bitset<8> bits2("11110000");

std::bitset<8> result_and = bits1 & bits2;  // 按位与：10100000
std::bitset<8> result_or = bits1 | bits2;   // 按位或：11111010
std::bitset<8> result_xor = bits1 ^ bits2;  // 按位异或：01011010
std::bitset<8> result_not = ~bits1;         // 按位取反：01010101
```

#### 注意事项

- `std::bitset` 的大小是固定的，在编译时确定。
- 如果位数超过 `unsigned long` 或 `unsigned long long` 的位数，`to_ulong()` 和 `to_ullong()` 会抛出 `std::overflow_error` 异常。
- `std::bitset` 不支持动态调整大小，如果需要动态位集，可以考虑 `std::vector<bool>`。

## 算法和迭代器

### \<algorithm>： 常用算法（如排序、查找等）

C++ 标准库中的 `<algorithm>` 头文件提供了一组用于操作容器（如数组、向量、列表等）的算法。这些算法包括排序、搜索、复制、比较等，它们是编写高效、可重用代码的重要工具。

`<algorithm>` 头文件定义了一组模板函数，这些函数可以应用于任何类型的容器，只要容器支持迭代器。这些算法通常接受两个或更多的迭代器作为参数，表示操作的起始和结束位置。

#### 语法

大多数 `<algorithm>` 中的函数都遵循以下基本语法：

```c
algorithm_name(container.begin(), container.end(), ...);
```

这里的 `container` 是一个容器对象，`begin()` 和 `end()` 是容器的成员函数，返回指向容器开始和结束的迭代器。

#### 1. 排序算法

函数：sort

定义：对容器中的元素进行排序。

语法：

```c
sort(container.begin(), container.end(), compare_function);
```

其中 compare_function 是一个可选的比较函数，用于自定义排序方式。

```c
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {5, 2, 9, 1, 5, 6};
  std::sort(numbers.begin(), numbers.end());

  for (int num : numbers) {
    std::cout << num << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

输出结果：

```
1 2 5 5 6 9 
```

**std::partial_sort**: 对部分区间排序，前 n 个元素为有序。

```
std::partial_sort(vec.begin(), vec.begin() + 3, vec.end());
```

**std::stable_sort**: 稳定排序，保留相等元素的相对顺序。

```
std::stable_sort(vec.begin(), vec.end());
```

#### 2. 搜索算法

函数：find

定义：在容器中查找与给定值匹配的第一个元素。

语法：

```c
auto it = find(container.begin(), container.end(), value);
```

如果找到，it 将指向匹配的元素；如果没有找到，it 将等于 container.end()。

```c
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> numbers = {1, 2, 3, 4, 5};
  auto it = std::find(numbers.begin(), numbers.end(), 3);

  if (it != numbers.end()) {
    std::cout << "Found: " << *it << std::endl;
  } else {
    std::cout << "Value not found." << std::endl;
  }

  return 0;
}
```

输出结果：

```
Found: 3
```

**std::binary_search**: 对有序区间进行二分查找。

```c
std::sort(vec.begin(), vec.end());  // 先排序
bool found = std::binary_search(vec.begin(), vec.end(), 4);
```

**std::find_if**: 查找第一个满足特定条件的元素。

```c
auto it = std::find_if(vec.begin(), vec.end(), [](int x) { return x > 3; });
```

#### 3. 复制算法

函数：copy

定义：将一个范围内的元素复制到另一个容器或数组。

语法：

```c
copy(source_begin, source_end, destination_begin);
```

```c
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> source = {1, 2, 3, 4, 5};
  int destination[5];
  std::copy(source.begin(), source.end(), destination);

  for (int i = 0; i < 5; ++i) {
    std::cout << destination[i] << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

输出结果：

```
1 2 3 4 5 
```

#### 4. 比较算法

函数：equal

定义：比较两个容器或两个范围内的元素是否相等。

语法：

```c
bool result = equal(first1, last1, first2);

bool result = equal(first1, last1, first2, compare_function);
```

```c
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
  std::vector<int> v1 = {1, 2, 3, 4, 5};
  std::vector<int> v2 = {1, 2, 3, 4, 5};

  bool are_equal = std::equal(v1.begin(), v1.end(), v2.begin());
  std::cout << (are_equal ? "Vectors are equal." : "Vectors are not equal.") << std::endl;

  return 0;
}
```

输出结果：

```c
Vectors are equal.
```

#### 5. 修改算法

**std::reverse**: 反转区间内的元素顺序。

```c
std::reverse(vec.begin(), vec.end());
```

**std::fill**: 将指定区间内的所有元素赋值为某个值。

```c
std::fill(vec.begin(), vec.end(), 0);  // 所有元素设为 0
```

**std::replace**: 将区间内的某个值替换为另一个值。

```c
std::replace(vec.begin(), vec.end(), 1, 99);  // 将所有 1 替换为 99
```

**std::copy**: 将区间内的元素复制到另一个区间。

```c
std::vector<int> vec2(6);
std::copy(vec.begin(), vec.end(), vec2.begin());
```

#### 6. 排列算法

**std::next_permutation**: 生成字典序的下一个排列，如果没有下一个排列则返回 false。

```c
std::vector<int> vec = {1, 2, 3};
do {
    for (int n : vec) std::cout << n << " ";
    std::cout << std::endl;
} while (std::next_permutation(vec.begin(), vec.end()));
```

**std::prev_permutation**: 生成字典序的上一个排列。

```c
std::prev_permutation(vec.begin(), vec.end());
```

#### 7. 归并算法

**std::merge**: 将两个有序区间合并到一个有序区间。

```c
std::vector<int> vec1 = {1, 3, 5};
std::vector<int> vec2 = {2, 4, 6};
std::vector<int> result(6);
std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
```

**std::inplace_merge**: 在单个区间中合并两个有序子区间。

```c
std::inplace_merge(vec.begin(), middle, vec.end());
```

#### 8. 集合算法

**std::set_union**: 计算两个有序集合的并集。

```c
std::vector<int> result(10);
auto it = std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
result.resize(it - result.begin());
```

**std::set_intersection**: 计算两个有序集合的交集。

```
auto it = std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
result.resize(it - result.begin());
```

**std::set_difference**: 计算集合的差集。

```
auto it = std::set_difference(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());
result.resize(it - result.begin());
```

#### 9. 其他有用算法

***std::accumulate*（需要 \<numeric> 库）**：计算范围内元素的累计和。

```c
#include <numeric>
int sum = std::accumulate(vec.begin(), vec.end(), 0);
```

**std::for_each**: 对区间内的每个元素执行操作。

```c
std::for_each(vec.begin(), vec.end(), [](int& x) { x += 1; });
```

**std::min_element** 和 **std::max_element**: 查找区间内的最小值和最大值。

```c
auto min_it = std::min_element(vec.begin(), vec.end());
auto max_it = std::max_element(vec.begin(), vec.end());
```

### \<iterator>： 迭代器

C++ 标准库中的 `<iterator>` 头文件提供了一组工具，用于遍历容器中的元素。迭代器是 C++ 标准模板库（STL）中的核心概念之一，它允许程序员以统一的方式访问容器中的元素，而不需要关心容器的具体实现细节。

迭代器是一个对象，它提供了一种方法来遍历容器中的元素。迭代器可以被视为指向容器中元素的指针，但它比指针更加灵活和强大。迭代器可以用于访问、修改容器中的元素，并且可以与 STL 算法一起使用。

迭代器主要分为以下几类：

1. **输入迭代器（Input Iterator）**：只能进行单次读取操作，不能进行写入操作。
2. **输出迭代器（Output Iterator）**：只能进行单次写入操作，不能进行读取操作。
3. **正向迭代器（Forward Iterator）**：可以进行读取和写入操作，并且可以向前移动。
4. **双向迭代器（Bidirectional Iterator）**：除了可以进行正向迭代器的所有操作外，还可以向后移动。
5. **随机访问迭代器（Random Access Iterator）**：除了可以进行双向迭代器的所有操作外，还可以进行随机访问，例如通过下标访问元素。

#### 语法

```c
#include <iterator>

// 使用迭代器遍历容器
for (ContainerType::iterator it = container.begin(); it != container.end(); ++it) {
    // 访问元素 *it
}
```

## 函数对象和绑定

### \<functional>： 定义函数对象及相关工具

C++ 标准库中的 `<functional>` 头文件提供了一组函数模板，这些模板允许我们使用函数对象（function objects）作为参数传递给算法，或者作为算法的返回值。函数对象是那些重载了 `operator()` 的对象，它们可以像普通函数一样被调用。

在 C++ 中，函数对象是一种特殊的类，它重载了 `operator()` 来允许对象像函数一样被调用。这使得我们可以将行为作为对象传递，增加了代码的灵活性和可重用性。

#### 常用函数对象

`<functional>` 头文件中定义了一些常用的函数对象，包括：

- `std::function`：一个通用的多态函数封装器。
- `std::bind`：用于绑定函数的参数。
- `std::plus`、`std::minus`、`std::multiplies`、`std::divides`、`std::modulus`：基本的算术操作。
- `std::equal_to`、`std::not_equal_to`、`std::greater`、`std::less`、`std::greater_equal`、`std::less_equal`：比较操作。
- `std::unary_negate`、`std::binary_negate`：逻辑否定操作。
- `std::logical_and`、`std::logical_or`、`std::logical_not`：逻辑操作。

##### 使用 `std::function`

`std::function` 是一个模板类，可以存储、调用和复制任何可调用对象，比如函数、lambda 表达式或函数对象。

```c
#include <iostream>
#include <functional>

void greet() {
  std::cout << "Hello, World!" << std::endl;
}

int main() {
  std::function<void()> f = greet; // 使用函数
  f(); // 输出: Hello, World!

  std::function<void()> lambda = []() {
    std::cout << "Hello, Lambda!" << std::endl;
  };
  lambda(); // 输出: Hello, Lambda!

  return 0;
}
```

#### 使用 `std::bind`

`std::bind` 允许我们创建一个可调用对象，它在调用时会将给定的参数绑定到一个函数或函数对象。

```c
#include <iostream>
#include <functional>

int add(int a, int b) {
  return a + b;
}

int main() {
  auto bound_add = std::bind(add, 5, std::placeholders::_1);
  std::cout << bound_add(10) << std::endl; // 输出: 15

  return 0;
}
```

在这个例子中，`std::placeholders::_1` 是一个占位符，它在调用 `bound_add` 时会被实际的参数替换。

#### 使用比较函数对象

比较函数对象可以用于算法，比如 `std::sort`。

```c
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

bool compare(int a, int b) {
  return a < b;
}

int main() {
  std::vector<int> v = {5, 3, 9, 1, 4};
  std::sort(v.begin(), v.end(), compare); // 使用自定义比较函数
  for (int i : v) {
    std::cout << i << " "; // 输出: 1 3 4 5 9
  }

  std::sort(v.begin(), v.end(), std::less<int>()); // 使用标准库比较函数对象
  for (int i : v) {
    std::cout << i << " "; // 输出: 1 3 4 5 9
  }

  return 0;
}
```





---

[C++ 标准库 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-standard-library.html)

[C++头文件及常见函数大全【蓝桥杯看这一篇基本就够了】_stdc++.h-CSDN博客](https://blog.csdn.net/2301_80544540/article/details/136952416)

[c++常用库函数（超级详细版）_c++库函数-CSDN博客](https://blog.csdn.net/m0_74036487/article/details/132766096)