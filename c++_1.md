---
最近通过[卡码网KamaCoder](https://kamacoder.com/)捡起了一点知识
---

# 输入输出函数处理特性对比表

## 输入函数对比

- "保留`\n`" = 把回车键也读进来
- "添加`\0`" = 自动补上字符串结束标记

| 函数             | 语言 | 自动添加`\n`           | 自动添加`\0` | 换行符处理         | 空白字符处理           | 其他特性              |
| :--------------- | :--- | :--------------------- | :----------- | :----------------- | :--------------------- | :-------------------- |
| `scanf("%s")`    | C    | ❌ 不添加               | ✅ 自动添加   | 开头跳过，中间停止 | 开头跳过，中间停止读取 | 格式化读取，不安全    |
| `scanf("%c")`    | C    | ❌ 不添加               | ❌ 不添加     | 正常读取           | 正常读取               | 唯一不跳过空白的scanf |
| `gets()`         | C    | ❌ **丢弃**输入中的`\n` | ✅ 自动添加   | 丢弃换行符         | 全部读取               | 不安全，已废弃        |
| `fgets()`        | C    | ✅ 保留输入中的`\n`     | ✅ 自动添加   | 保留换行符         | 全部读取               | 安全推荐，指定长度    |
| `fgetc()/getc()` | C    | ❌ 不添加               | ❌ 不添加     | 正常读取           | 正常读取               | 单个字符读取          |
| `getchar()`      | C    | ❌ 不添加               | ❌ 不添加     | 正常读取           | 正常读取               | 单个字符，默认stdin   |

| 函数                | 语言 | 自动添加`\n`       | 自动添加`\0`         | 换行符处理         | 空白字符处理           | 其他特性             |
| :------------------ | :--- | :----------------- | :------------------- | :----------------- | :--------------------- | :------------------- |
| `cin >>`            | C++  | ❌ 不添加           | ✅ 自动添加（字符串） | 开头跳过，中间停止 | 开头跳过，中间停止读取 | 格式化读取，类型安全 |
| `cin.get()`         | C++  | ❌ 不添加           | ✅ 自动添加（字符串） | 正常读取           | 正常读取               | 保留空白字符         |
| `cin.getline()`     | C++  | ❌ 丢弃输入中的`\n` | ✅ 自动添加           | 丢弃换行符         | 全部读取               | 安全推荐，指定长度   |
| `getline(cin, str)` | C++  | ❌ 丢弃输入中的`\n` | ✅ string自动管理     | 丢弃换行符         | 全部读取               | C++推荐，动态内存    |

## 输出函数对比

- "添加`\n`" = 自动帮你按回车换行
- 输出函数不关心`\0`，因为它只负责显示内容

| 函数             | 语言 | 自动添加`\n`   | 自动添加`\0` | 换行符处理 | 空白字符处理 | 其他特性             |
| :--------------- | :--- | :------------- | :----------- | :--------- | :----------- | :------------------- |
| `printf()`       | C    | ❌ 需要手动添加 | ❌ 不添加     | 手动控制   | 手动控制     | 格式化输出，灵活     |
| `puts()`         | C    | ✅ 自动添加     | ❌ 不添加     | 自动换行   | 原样输出     | 简单字符串输出       |
| `fputs()`        | C    | ❌ 需要手动添加 | ❌ 不添加     | 手动控制   | 原样输出     | 文件/标准输出        |
| `fputc()/putc()` | C    | ❌ 需要手动添加 | ❌ 不添加     | 手动控制   | 原样输出     | 单个字符输出         |
| `putchar()`      | C    | ❌ 需要手动添加 | ❌ 不添加     | 手动控制   | 原样输出     | 单个字符，默认stdout |

| 函数           | 语言 | 自动添加`\n`     | 自动添加`\0` | 换行符处理    | 空白字符处理 | 其他特性           |
| :------------- | :--- | :--------------- | :----------- | :------------ | :----------- | :----------------- |
| `cout <<`      | C++  | ❌ 需要手动添加   | ❌ 不添加     | 手动控制      | 原样输出     | 类型安全，链式调用 |
| `cout << endl` | C++  | ✅ 自动添加并刷新 | ❌ 不添加     | 自动换行+刷新 | 原样输出     | 推荐换行方式       |
| `cerr <<`      | C++  | ❌ 需要手动添加   | ❌ 不添加     | 手动控制      | 原样输出     | 无缓冲错误输出     |
| `clog <<`      | C++  | ❌ 需要手动添加   | ❌ 不添加     | 手动控制      | 原样输出     | 缓冲日志输出       |

## '\0'与'\n'对比

### （1）\0

其实就是0，[字符串](https://zhidao.baidu.com/search?word=字符串&fr=iknow_pc_qb_highlight)存入[字符数组](https://so.csdn.net/so/search?q=字符数组&spm=1001.2101.3001.7020)的时候最后一个字符作为字符串的结尾。告诉计算机，这个字符串结束了。在处理字符串需要清理换行符'\n'的时候，我们可以把'\n'='\0'；

#### sizeof

```c
#include <stdio.h>
using namespace std;
int main()
{
  char c1[] = {'I', ' ', 'a', 'm', ' ', 'h', 'a', 'p', 'p', 'y'};
  char c2[] = "I am happy";//字符串常量"I am happy"的最后由系统自动加上一个’\0’
  int i1 = sizeof(c1);
  int i2 = sizeof(c2);
  printf("%d\n", i1);
  printf("%d\n", i2);
  return 0;
}
//下面的赋值方法是错误的
//char str[ ];
//str=“I am happy”;
```

输出：

```
10
11
```

#### strlen

在字符串中‘\0’代表空字符，‘\0’ASCII值为0. 所以可认为‘\0’ == 0.

strlen函数工作机理：函数从第一个字符开始计算字符串中字符数，直到遇到空字符，然后返回空字符前字符总个数。

```c
/*01*/char * str1 = "abc"; //'a''b''c' 
                         
/*02*/char * str2 = "ab\0c";//'a''b'

/*03*/char * str3 = "ab\\0c";// 'a''b''\'0''c''c'

/*04*/char * str4 = "abc0c";//'a''b''c''0''c'

/*05*/char arr0[5] = {'1', '2', '3', '4', '5'};//这是一个字符数组，他里面存放的并不是字符串 (因为无’\0’)，只是一系列字符因为最后无空字符，所以strlen一直寻找直到遇到第一个空字符，此时结果不可预知(幸运的是，内存中’\0’还是蛮多的).比如我自己试了两次，一次strlen( arr0[5] ) = 15，一次16

/*06*/char arr1[5] = {'1', '2', '3', '4', '\0'};//'1''2''3''4'

/*07*/char arr2[5] = {'1', '2', '3', '4', 0};//0=='\n'

/*08*/char arr3[5] = {'0', '0', '0'};//前三个元素为字符‘0’ ！= 数字0 （’\0’），因为部分初始化，数组剩下元素被设置为数字0，因此第四个元素为0 == ‘\0’。终止，所以为3.（数组声明后不初始化，里面值为随机值，部分初始化后，未被初始化部分自动被初始化为0）

/*09*/char arr4[5] = {0, 'a', 'b'};

/*10*/char arr5[5] = {'a', '\0', 'b'};

/*11*/char arr6[5] = {'a', 0, 'b'};
```

输出：

```c
01——3
02——2 
03——5
04——5
05——未知
06——4
07——4
08——3
09——0
10——1
11——1
```

#### 总结

1.字符串和字符数组的区别和联系:
**C语言中没有一个用于表示字符串的关键字；**
**C语言的字符串由C的字符数组变形而成，末尾加上’\0’，即字符串比字符数组多一个’\0’;**

2.数字0，’\0’ ，字符0的关系：
在字符串中‘\0’代表空字符，‘\0’ASCII值为数字0. 所以可认为‘\0’ == 0.
注意只有数字0才会被当做空字符’\0’哦，字符0（即’0’）还是不会被当做空字符的。
比如char *str = “abc0”，char str1[] = “abc0”；这里字符串"abc0"中的0会被当做字符0（即’0’），strlen()不终止;
再比如char str2[] = {‘a’, ‘b’, ‘c’, ‘0’}，这个字符数组str2就相当于字符串str，strlen()函数求长度都是4；
再比如char str3[] = {‘a’, ‘b’, ‘c’, ‘\0’}，char str4[] = {‘a’, ‘b’, ‘c’, 0}；这俩是求长度是一样的，原因就是上面的’\0’ 和 数字0均认为是空字符；

3.我们再来看看"abc\0d"这个字符串（而不是字符数组），系统在d字符后还加空字符吗？ 它里面已经有空字符了？
系统还是会加的，因为系统只负责在引号中最后一个字符结尾加一个空字符，然后根据你占用的空间大小以字节为单位给字符串开辟空间，它才不管你字符串里面有没有空字符
( 按照约定，空字符代表字符串结束，所以平时不要在字符串内部加空字符 )

我们可以通过sizeof关键字来验证，sizeof以字节为单位返回所占空间大小，包括空字符， 而strlen是计算长度直到遇到空字符停止，对他来说遇到空字符就停止工作。

如果系统在"abc\0d"末尾加空字符，那么sizeof（“abc\0d”）的返回值应该为6(‘\0’当一个字符对待)，不加则为5。经验证为6，说明系统在最后是加空字符的(也说明了字符串中的空字符并不起终止字符串存储的作用，系统只是把’\0’当字符串中一个字符对待)。

sizeof(“abc\0”) == 5 （ 系统加了一个空字符’\0’，所以为5；另外strlen(“abc\0”)==3）

sizeof(“abc\0\0”) == 6（系统加了一个空字符’\0’，所以为6；另外strlen(“abc\0\0”)==3）

sizeof(“abc\0d”）== 6（系统加了一个空字符’\0’，所以为6；另外strlen(“abc\0d”)==3）

还想到一种验证方法（可看可不看），针对"abc\0d"实现一个函数，函数遇到第二个空字符返回包括第二个空字符在内的字符串字符总个数，即可以验证系统在这个字符串后还加没加空字符。（如果加程序返回6，如果不加则不是6，是一个随机值，or 程序直接出错）。


### （2）\n

是回车换行符

### 其他转义字符

| 转义字符 | 含义           | [ASCII](https://c.biancheng.net/c/ascii/) 码值（十进制） | 详细解释                                                     |
| -------- | -------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| \a       | 警报（响铃）   | 7                                                        | 发出系统提示音，通常用于引起用户注意。在某些系统中可能没有明显效果。 |
| \b       | 退格           | 8                                                        | 将光标位置向左移动一个字符。如果光标已经在行首，则行为可能因系统而异。 |
| \f       | 换页           | 12                                                       | 将光标移动到下一页的开头。在打印输出时很有用，但在屏幕输出中可能显示为空白字符。 |
| \n       | 换行           | 10                                                       | 将光标移动到下一行的开头。这是最常用的行结束符，用于文本的换行。 |
| \r       | 回车           | 13                                                       | 将光标移动到当前行的开头。通常与 \n 配合使用，在 Windows 系统中表示换行。 |
| \t       | 水平制表符     | 9                                                        | 将光标移动到下一个制表位置。通常用于对齐文本或创建缩进效果。 |
| \v       | 垂直制表符     | 11                                                       | 在支持的设备上，将光标向下移动到下一个垂直制表位置。在大多数现代终端中，效果可能与 \n 相同。 |
| \\       | 反斜杠         | 92                                                       | 用于在字符串中表示一个字面意义上的反斜杠字符。               |
| \\'      | 单引号         | 39                                                       | 用于在字符常量中表示一个字面意义上的单引号字符。             |
| \\"      | 双引号         | 34                                                       | 用于在字符串常量中表示一个字面意义上的双引号字符。           |
| \?       | 问号           | 63                                                       | 用于表示字面意义上的问号，主要用于避免触发三字符序列。       |
| \0       | 空字符（NULL） | 0                                                        | 表示字符串的结束。在 C 语言中，字符串以空字符结尾。          |
| \xhh     | 十六进制值     | -                                                        | 表示一个十六进制值，其中 hh 是一个或多个十六进制数字。例如，\x41 表示字符 'A'。 |
| \ooo     | 八进制值       | -                                                        | 表示一个八进制值，其中 ooo 是一到三个八进制数字。例如，\101 表示字符 'A'。 |

---

# 输入/输出

C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做**输入操作**。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做**输出操作**。

## 标准输入流
### C 标准输入
C语言使用标准输入输出函数，需要包含头文件`<stdio.h>`。而在 C++ 中，只要包含头文件`<iostream>`，就完全可以使用这些 C 中的输入输出函数。

### 标准输入流及对缓冲区的理解
`stdin`是一个文件描述符（Linux）或句柄（Windows），它在 C 程序启动时就被默认分配好。在 Linux 中一切皆文件，stdin也相当于一个可读文件，它对应着键盘设备的输入。因为它不断地被输入，又不断地被读取，像流水一样，因此通常称作输入流。

`stdin`是一种行缓冲I/O。当在键盘上键入字符时，它们首先被存放在键盘设备自身的缓存中（属于键盘硬件设备的一部分）。只有输入换行符时，操作系统才会进行同步，将键盘缓存中的数据读入到`stdin`的输入缓冲区（存在于内存中）。所有从`stdin`读取数据的输入流，都是从内存中的输入缓冲区读入数据。当输入缓冲区为空时，函数将被阻塞。

若无特殊说明，以下所有的**“缓冲区”**均是指内存中的`stdin`输入缓冲区。用户程序中自定义的`buffer`数组、`str`数组等，将称作“数组”、“变量”，以免产生混淆。

### `scanf()`
按照特定格式从`stdin`读取输入。

#### 用法示例：

``` c
char str[100];
int a;
scanf("%s %d", str, &a);    // 注意，传入的一定是变量的地址
```

#### 对空白字符的处理：

1. 缓冲区开头：丢弃空白字符（包括空格、Tab、换行符），直到第一个非空白字符才认为是第一个数据的开始。

2. 缓冲区中间：开始读取第一个数据后，一旦遇到空白字符（非换行符）， 就认为读取完毕一次。遇到的空白字符残留在缓冲区，直到下一次被读取或刷新。例如输入字符串this is test，则会被认为是3个字符串。

3. 缓冲区末尾：按下回车键时，换行符\n残留在缓冲区。换行符之前的空格可以认为是中间的空白字符，处理同上。

   注意，格式控制符只会读取正确类型的变量。如果输入格式不正确，比如在%d处输入了一个字符a，则会使读取中断，即后续不读取任何变量。

#### 格式控制符说明：

| 占位符 | 类型             | 说明                                       | 示例                 |
| ------ | ---------------- | ------------------------------------------ | -------------------- |
| `%d`   | `int`            | 读取带符号的十进制整数                     | `scanf("%d", &a);`   |
| `%u`   | `unsigned int`   | 读取无符号的十进制整数                     | `scanf("%u", &a);`   |
| `%f`   | `float`          | 读取浮点数                                 | `scanf("%f", &a);`   |
| `%lf`  | `double`         | 读取双精度浮点数                           | `scanf("%lf", &a);`  |
| `%c`   | `char`           | 读取单个字符                               | `scanf("%c", &a);`   |
| `%s`   | `char[]`         | 读取字符串（以空格为分隔符）               | `scanf("%s", str);`  |
| `%x`   | `unsigned int`   | 读取十六进制整数                           | `scanf("%x", &a);`   |
| `%o`   | `unsigned int`   | 读取八进制整数                             | `scanf("%o", &a);`   |
| `%p`   | `void*`          | 读取指针地址                               | `scanf("%p", &ptr);` |
| `%hd`  | `short int`      | 读取短整型                                 | `scanf("%hd", &a);`  |
| `%ld`  | `long int`       | 读取长整型                                 | `scanf("%ld", &a);`  |
| `%lld` | `long long int`  | 读取长长整型                               | `scanf("%lld", &a);` |
| `%Lf`  | `long double`    | 读取长双精度浮点数                         | `scanf("%Lf", &a);`  |
| `%e`   | `float`/`double` | 读取科学记数法表示的浮点数（小写）         | `scanf("%e", &a);`   |
| `%E`   | `float`/`double` | 读取科学记数法表示的浮点数（大写）         | `scanf("%E", &a);`   |
| `%g`   | `float`/`double` | 自动选择 `%e` 或 `%f` 中较短的形式（小写） | `scanf("%g", &a);`   |
| `%G`   | `float`/`double` | 自动选择 `%E` 或 `%F` 中较短的形式（大写） | `scanf("%G", &a);`   |
| `%%`   | —                | 读 `%` 符号本身（不存值）                  | `scanf("%%");`       |

注意，`%c`是一个比较特殊的格式符号，它将会读取所有空白字符，包括缓冲区开头的空格、Tab、换行符，使用时要特别注意。上面所有占位符除了`%c`，都会自动忽略输入中的所有空白字符（如空格和换行符），但是%c不会忽略空白字符，它总是会返回当前的第一个字符，无论是不是空白字符。
如果要强制跳过字符前的空白字符，可以写成` scanf(" %c", &ch) `，这里在`%c`前面加上了一个空格，表示跳过字符前的所有空白字符。

`scanf()`的读取也没有边界，所以并不安全。C11 标准提供了安全输入scanf_s()。

> 1. scanf 会忽略空白字符（空格、换行符和制表符），直到它找到一个有效的输入。
>   Q：scanf(“%d %d")和scanf(“%d%d")有什么区别？
>   A：没有区别。在两个 %d 之间的空格表示“忽略所有空白字符（包括空格、换行、制表符等），直到读取下一个数字。但是如果两个 %d 之间没有空格，scanf 依然能够正确地读取两个整数，因为它会自动忽略输入中的所有空白字符来解析下一个 %d。
>   Q：scanf("%d")和scanf("%d ")有什么区别?
>   A：scanf("%d")会自动忽略前导空白字符，直到遇到第一个非空白字符开始读取整数，到空白字符或者非数字字符（对于%d来讲是无效字符）结束，并且会停止在下一个空白字符处（读到数字之后停止后的第一个空白字符）。如果输入的是 123，它会成功读取 123，并且跳过后面的空白字符。scanf("%d ")这个格式字符串也会从标准输入中读取一个整数，但它要求输入后有至少一个空白字符。由于格式字符串最后有一个空格，它告诉 scanf 在读取完整数后，期望继续读取空白字符，如果输入是 123 后没有任何空格或者换行，scanf("%d ")会阻塞等待输入空白字符，直到用户输入至少一个空格或者换行符。这是一个非常常见的易错点，有时候程序阻塞却找不到原因，就是scanf中占位符后面的这个空格导致的
>
> 2. %s 格式说明符用于读取一个字符串，但它只能读取到第一个空白字符为止。
>
>   当输入123 4567时，只将123存入了s中，因为scanf读到空白字符就停止了
>
>   ![image-20251005190901592](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190901592.png)
>
>   **注意：** scanf在读取字符串的时候，不会检查读取的字符串的长度是否超过了字符数组的长度，这样一来就容易导致**未定义的行为**。
>
>   可以通过 %9s 格式限定最大输入长度，以防止缓冲区溢出（会导致程序崩溃或未定义行为）。s的长度为10，限制输入9个字符，留一个给’\0’ 。
>
>   ![image-20251005190926003](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190926003.png)
>
>   3. 使用 & 取地址符来将变量传递给 scanf，这是因为 scanf 需要修改这些变量的值，但是如果要存储数据的变量是数组就不需要取地址。
>
>   4. scanf 的返回值是成功读取的项数。如果输入失败，返回值可能是 0 或 EOF。
>
>   在题目中可以搭配循环用来读取测试用例
>
>   ![image-20251005191007395](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005191007395.png)
>
>   

### `gets()` - 不建议
按下回车键时，从`stdin`读取一行。

#### 用法示例：

```c
char str[100];
gets(str);
```

#### 对空白字符的处理：

1. 所有空格、Tab等空白字符均被读取，不忽略。
2. 按下回车键时，缓冲区末尾的换行符被丢弃，字符串末尾没有换行符\n，缓冲区也没有残留的换行符\n。
   注意，`gets()`不能指定读取上限，因此容易发生数组边界溢出，造成内存不安全。C11 使用了`gets_s()`代替`gets()`，但有时编译器未必支持，因此总体来说不建议使用`gets()`函数来读取输入。

### `fgets()`
从指定输入流读取一行，输入可以是`stdin`，也可以是文件流，使用时需要显式指定。

#### 读取文件流示例：

```c
char str[100];
memset(str, 0, sizeof(str));
int i = 1;

FILE *fp = fopen("...test.txt", "r");
if (fp == NULL) {
    printf("File open Error!\n");
    exit(1);
}

while (fgets(str, sizeof(str), fp) != NULL)
    printf("line%d [len %d]: %s", i++, strlen(str), str);

fclose(fp);
```

#### 读取`stdin`示例：

```c
char str[100];
memset(str, 0, sizeof(str));
int i = 1;
while (fgets(str, sizeof(str), stdin) != NULL)
    printf("line%d [len %d]: %s", i++, strlen(str), str);
```

#### 对空白字符的处理：

1. 所有空格、Tab等空白字符均被读取，不忽略。
2. 按下回车键时，缓冲区末尾的换行符也被读取，字符串末尾将有一个换行符\n。例如，输入字符串hello，再按下回车，则读到的字符串长度为6。

`fgets()`函数会自动在字符串末尾加上\0结束符。

第 2 个参数n指定了读取的最大长度。函数读到n-1个字符（包括换行符\n）就会停止，并在末尾加上\0结束符。剩余字符将残留在缓冲区。

建议使用`fgets()`完全替代`gets()`。

### `fgetc()` &` getc()`
从指定输入流读取一个字符，输入可以是`stdin`，也可以是文件流，使用时需要显式指定。

这两个函数完全等效，`getc()`由`fgetc()`宏定义而来。不同的是，前述的`gets()`和`fgets()`相互之间没有关系。

#### 用法示例：

```c
char a, b;
a = fgetc(stdin);
b = getc(stdin);
```

#### 对空白字符的处理：

1. 所有空格、Tab、**换行**等空白字符，无论在缓冲区开头、中间还是结尾，均会被读取，不忽略。
2. 因为只读取一个字符，所以如果输入多于1个字符（包括换行符），则它们均会残留在缓冲区。具体地说，如果什么字符都不输入，直接按下回车键，则读取到的是换行符\n，缓冲区无任何残留；如果输入一个字符如a，然后按下回车键，则读取到的是字符a，同时换行符\n残留在缓冲区。

`fgetc()`和`getc()`对应的输出函数是`fputc()`和`putc()`。

### `getchar()`
从`stdin`读取一个字符。

`getchar()`实际上也由`fgetc()`宏定义而来，只是默认输入流为`stdin`。

#### 用法示例：

```c
char a;
a = getchar();
```

`getchar()`常常用于清理缓冲区开头残留的换行符。当知道缓冲区开头有\n残留时，可以调用`getchar()`但不赋值给任何变量，即可实现冲刷掉\n的效果。

```c
int getchar(void);
```

`getchar()` 函数返回从键盘输入的一个字符的 ASCII 码值，如果读取失败，则返回 `EOF`（即 -1）。  使用时不带任何参数。

```c
#include <cstdio>
int main()
{
	int ret = getchar();//输入` x`（空格加x）
	putchar(ret);//输出空格，不读到x
	return 0;
}
```

> Q：返回值为什么要设计为int而不是char?
> A：如果读取失败，返回常量 `EOF` ，由于` EOF `通常是 -1 ，所以返回值的类型要设为 int ，而不是 char。
> Q：怎么模拟读取失败，让 `getchar()` 返回 -1 ？
> A：在输入时按 `Ctrl` + `Z` 即可。

## C++ 标准输入

C++中使用标准输入输出需要包含头文件`<iostream>`。一般使用`iostream`类进行流操作，其封装很完善，也比较复杂，本文只介绍一部分。

### `cin`
`cin`是 C++ 的标准输入流对象，即istream类的一个对象实例。`cin`有自己的缓冲区，但默认情况下是与`stdin`同步的，因此在 C++ 中可以混用 C++ 和 C 风格的输入输出（在不手动取消同步的情况下）。

`cin`与`stdin`一样是行缓冲，即遇到换行符时才会将数据同步到输入缓冲区。

`cin`的用法非常多，只列举常用的几种。最常用的就是使用>>符号（该符号形象地体现了“流”的特点）。

#### 用法示例：

```c
int a, b;
cin >> a >> b;
char str[20];
cin >> str;
```

`cin`对空白字符的处理与scanf一致。即：跳过开头空白字符，遇到空白字符停止读取，且空白字符（包括换行符）残留在缓冲区。

如果不想跳过空白字符，可以使用流控制关键词noskipws（no skip white space），但这只对单个字符有效（类似于scanf中的%c）。

```c
char c;
cin >> noskipws >> c;
```

注意，`cin`对象属于命名空间std，如果想使用`cin`对象，必须在 C++ 文件开头写`using namespace std`，或者在每次用到的时候写成`std::cin`。

> Q：那么cin的结束标志是什么呢？按下回车cin就结束了吗？
> A：回车（Enter）不会单独作为终止标志：
> 当你按下回车，如果当前的 cin 读取完成，程序会继续执行。
> 但如果 cin 需要更多输入（如多个 cin >> 变量;），这时如果完成了部分的 cin 输入之后按下回车，cin并不会停止，它还是会等待输入。
>
> ```C
> #include <iostream>
> using namespace std;
> //二叉树链式存储（存左右结点）
> const int N = 300;
> char l[N],r[N];
> char root;
> int n;
> 
> void dfs(char root)
> {
> 	cout << root;
> 	if(l[root] != '*') dfs(l[root]);
> 	if(r[root] != '*') dfs(r[root]);
> }
> 
> int main() 
> {
> 	cin >> n;
> 	cin >> root;
> 	cin >> l[root] >> r[root];
> //	cin >> root >> l[root] >> r[root]; cin是以空格为分隔符 
> 	for(int i=2;i<=n;i++)
> 	{
> 		char t; cin >> t;
> 		cin >> l[t] >> r[t];
> 	}
> 	dfs(root);
> 	return 0;
> }
> ```
>
> 输入数据为
>
> ```c
> 6
> abc
> bdi
> cj*
> d**
> i**
> j**
> ```
>
> 错误想法：如果使用cin >> root >> l[root] >> r[root];读取数据，就会发现能成功将a读到root中，l[root]和r[root]都读不到内容，这是因为多个cin连续读取数据的时候是以空白字符为分割符号，像abc这样没有空白字符分割的数据，cin会以为abc都是给root的，但是root是个char类型，读不下这么多东西，后面的bc就废掉了。
>
> 即使输入数据不用空白字符分开，cin可以通过变量类型解析数据来成功读取。
> 如下图所示，定义了三个char类型的变量root1、root2、root3，在输入数据的时候直接给的abc，仍然能正确读取。
>
> ![image-20251005191411546](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005191411546.png)
>
> 那么原因到底是什么呢？因为root变量没有初始化，root直接定义在全局中，程序确实会自动给它赋值为0，但是这仍然叫做root没有初始化，当cin >> l[root] >> r[root]的时候，实际上这是不可预测行为，数组 l[root] 和 r[root] 需要索引，而 root 还未初始化。
>
> 如下图所示，将root1定义在main函数中，并且将其初始化为'a'，此时我再执行cin >> root >> l[root] >> r[root];的操作的时候就能成功将三个数据全部读取到，因为root1已经初始化过了，这样的操作是安全的。
>
> ![image-20251005191502696](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005191502696.png)
>
>
> 继续解释，如下图所示，我定义了一个变量tmp = 10，并且将l和r数组下标为tmp的地方的值都改成了'f'，然后再连续读取 root、l[tmp]、r[tmp]，这时候的tmp下标是已经定义过了的，所以在读取时没有任何问题，成功的将l[tmp]、r[tmp]的值修改成了'b'、'c'。
>
> ![image-20251005191522331](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005191522331.png)
>
> Q：cin 和 cout 能进行连续输入输出吗？
> A：可以。使用 cout 进行变量的输出，实质上是将变量插入到 cout 对象里，并以 cout
> 对象作为返回值返回，因此我们还可以用 << 在后面连续输出多个内容。

### `cin.get()`
读取单个或指定长度的字符，包括空白字符。

### 用法示例：

```c
char a, b;
char str[20];

// 读取一个字符，读取失败时返回0，多余字符残留在缓冲区（包括换行符）
a = cin.get();

// 读取一个字符，读取失败时返回EOF，多余字符残留在缓冲区（包括换行符）
cin.get(b);

// 在遇到指定终止字符（参数3）前，至多读取n-1个（参数2）字符
// 当不指定终止字符时，默认为换行符\n
// 如果输入的字符个数小于等于n-1（不含终止字符），则终止字符不残留在缓冲区
// 如果输入的字符个数多于n-1（不含终止字符），则余下字符将残留在缓冲区
cin.get(str, sizeof(str), '\n');
```

`cin.get()`读取单个字符时，类似于 C 中的`fgetc()`，对空白字符的处理也与其一致。`cin.get()`读取的字符也可以赋值给整型变量。

`cin.get()`读取指定长度个字符时，类似于 C 中的`fgets()`，但在换行符的处理上不同。它们都不会使换行符残留在缓冲区，但`fgets()`会将缓冲区末尾的换行符\n也写入字符串，而`cin.get()`会丢弃缓冲区末尾的\n。即：当输入test时，用fgets()读取得到的字符串长度为5，用`cin.get()`读取得到的字符串长度为4。

### `cin.getline()`
读取指定长度的字符，包括空白字符。

#### 用法示例：

```c
char str[20];
cin.getline(str, sizeof(str));    // 第3个参数也可以指定终止字符
```

`cin.getline()`与`cin.get()`指定读取长度时的用法几乎一样。区别在于，如果输入的字符个数大于指定的最大长度n-1（不含终止符），`cin.get()`会使余下字符残留在缓冲区，等待下次读取；而`cin.getline()`会给输入流设为 Fail 状态，在主动恢复之前，无法再进行正常输入。

### `getline()`
`getline()`并不是标准输入流istream的函数，而是字符串流`sstream`的函数，只能用于读取数据给**string类对象**，使用时也需要包含头文件`<string>`。

如果使用`getline()`读取标准输入流的数据，需要显式指定输入流。

#### 用法示例：

```c
string str;
getline(cin, str);
```

getline()会读取所有空白字符，且缓冲区末尾的换行符会被丢弃，不残留也不写到字符串结尾。同时，由于string对象的空间是动态分配的，所以会一次性将缓冲区读完，不存在读不完残留在缓冲区的问题。

需要注意的是，假如缓冲区开头就是换行符（比如可能是上一次`cin`残留的），则`getline()`会直接读取到空字符串并结束，不会给键盘输入的机会。所以这种情况下要注意先清除开头的换行符。

### 总结
在 C 中，建议使用`scanf()`进行格式化读取，用`fgets()`读取整行，用`fgetc()`或`getchar()`读取单个字符。

在 C++ 中，建议使用`cin` >>进行格式化读取，而`cin.get()`、`cin.getline`、`getline(string)`有各自的适用情况。

注意`fgets()`和`cin.get()`在对换行符的清理方面有所区别。

## 标准输出流

### C 标准输出
#### 标准输出流及对缓冲区的理解
相应于输入流的`stdin`，输出流也有其默认的文件描述符`stdout`，对应着命令行终端（Windows 中称为控制台）的显示。此外，还有对应错误输出的`stderr`，默认也是终端的显示。它们都可以被重定向到文件中以便持久保存和查看，在此不作赘述。

`stdout`也是行缓冲I/O，它与`stdin`类似也有三者之间的数据同步：从用户程序到`stdout`的输出缓冲区，由用户程序决定；从`stdout`的输出缓冲区到终端的显示，只有缓冲区末尾遇到换行符\n才会进行。如果输出缓冲区末尾没有换行符\n，是不会打印显示输出的。

例如以下程序：

```c
// 程序 1
int main(int argc, char* argv[])
{
    printf("Hello World!\n");
    while(1){}
    return 0;
}

// 程序 2
int main(int argc, char* argv[])
{
    printf("Hello World!");
    while(1){}
    return 0;
}

// 程序 3
int main(int argc, char* argv[])
{
    printf("Hello World!")
    return 0;
}

// 程序 4
int main(int argc, char* argv[])
{
    printf("Hello World!\nABCDE");
    while(1){}
    return 0;
}
```

程序 1 中，printf()输出内容的最后有换行符\n，所以将在屏幕上输出Hello World!并换行，然后进入while(1)循环阻塞住。

程序 2 中，把\n去掉了，此时终端不会显示任何内容。因为程序进入死循环后，没有机会向stdout中写入\n使其清空缓冲。

程序 3 中，虽然没有写入换行符，但是依然能够在终端打印Hello World!（只是没有换行）。这是因为程序结束时会自动清空缓冲区。（除此之外，当缓冲区被填满时也会自动清空）

程序 4 能够进一步加深对行缓冲的理解。它在程序 1 的基础上，在换行符之后又加上了几个字符。运行可以发现终端只打印了Hello World!并换行，而没有打印ABCDE。

输出函数通常没有针对对空格、制表符的特殊行为，比输入要简单一些。特殊的处理一般只有换行符。

### `printf()`
按照特定格式将stdout缓冲区的内容打印到终端。

#### 用法示例：

```c
printf("Number a = %d", a);      // 十进制整数
printf("Number b = %.2f", b);    // 浮点数，保留两位小数
printf("String s = %s", s);      // 字符串
```

`printf()`的写法与`scanf()`十分相像。区别在于`scanf()`中一般只有格式控制字符，而没有其他普通字符，而`printf()`中常常是在一串字符中把要替换的内容写为格式控制字符，从而形成格式化输出的效果。 

| 占位符 | 含义说明                                     |
| ------ | -------------------------------------------- |
| `%d`   | 十进制有符号整数                             |
| `%u`   | 十进制无符号整数                             |
| `%f`   | 浮点数（`float` 和 `double` 均用 `%f` 输出） |
| `%s`   | 字符串                                       |
| `%c`   | 单个字符                                     |
| `%e`   | 指数形式的浮点数                             |
| `%g`   | 自动选 `%e` 或 `%f` 中较短的形式输出         |
| `%x`   | 无符号十六进制整数（小写）                   |
| `%X`   | 无符号十六进制整数（大写）                   |
| `%o`   | 无符号八进制整数                             |
| `%p`   | 指针地址值                                   |
| `%lu`  | 32 位无符号整数（`unsigned long`）           |
| `%llu` | 64 位无符号整数（`unsigned long long`）      |
| `%%`   | 输出百分号 `%` 本身                          |

#### 定制输出格式
1.限定占位符的最小宽度
例如：%5d表示这个占位符的宽度至少为5，输出的整数宽度至少为5，如果不满5位就默认在前面用空格补齐（右对齐）。如果希望改为左对齐，就要加一个负号，即%-5d。

正常输出：

![image-20251005190243236](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190243236.png)

设定占位符宽度为5，默认右对齐

![image-20251005190314266](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190314266.png)

设定占位符宽度为5，左对齐

![image-20251005190327907](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190327907.png)

2.限定小数位数
当`printf`以`%f`的格式输出时，默认输出的小数位数是6，如果想改变输出的小数位数，就要加点符号并在后面写上想要限制的位数。例如想要保留小数点后两位，占位符可以写为`%.2f`

默认输出6位小数：

![image-20251005190356830](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190356830.png)

修改为输出2位小数：
![image-20251005190410247](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251005190410247.png)

### `puts()`
将字符串和一个尾随的换行符\n写入到`stdout`的缓冲区。根据行缓冲的性质，终端也会立即进行打印显示。

#### 用法示例：

```c
puts("hello");    // 立即输出hello并换行
```

`puts()`对换行符的处理与`gets()`“相反”。**`gets()`会自动丢弃一个换行符，而`puts()`则是自动写入一个换行符。**

### `fputs()`
将字符串写入指定输出流，可以是文件流、`stdout`或`stderr`等。`stderr`是标准错误流，它是无缓冲的，会立即输出到屏幕，而不是等待换行符才输出。

#### 用法示例：

```c
fputs("hello world", stdout);    // 不会立即输出
fputs("hello world\n", stdout);  // 立即输出
fputs("hello world", `stderr`);  // 立即输出
```

与`fgets()`一样，`fputs()`不会主动操作换行符。如果希望立即输出，需要自己加上换行符\n。

### `fputc()` &` putc()`
将一个字符写入指定输出流，可以是文件流、`stdout`或`stderr`等。

#### 用法示例：

```c
char c = 'q';
fputc(c, stdout);
c = '\n';
putc(c, stdout);
```

`fputc()`和`putc()`只是把字符写入stdout，没有任何额外操作。因此如果希望立即输出，需要自己加上换行符\n。

### `putchar()`
将一个字符写入到标准输出流`stdout`。

#### 用法示例：

```c
char c = 'x';
putchar(c);
```

```c
int putchar(int ch);
```

参数：需要输出的字符（int 类型，通常表示为字符）。
返回值：返回输出的字符（作为 int 类型）或者 EOF（如果输出失败）。

同上，`putchar()`不操作换行符。如果希望立即输出，需要自己加上换行符\n。

### `fflush()`
该函数的功能是强制刷新缓冲区，将数据立即写到对应的文件（或设备）。其参数可以是文件流指针，也可以是`stdout`。

#### 用法示例：

```c
fputs("Hello World!", stdout);
fflush(stdout);
while (1);
```

上面的程序在进入死循环前，会输出Hello World!字符串到屏幕。

注意：不能够将`fflush()`用于`stdin`！这可能导致不可预料的后果。

## C++ 标准输出
### `cout`
`cout`是`ostream`类的一个实例。`cout`是行缓冲的。

#### 用法示例：

```c
char str[] = "hello world";
cout << "str: " << str << endl;
```

插入endl对象时，将立即清空输出缓冲区并显示，然后输出一个换行符\n。

也有`cout.put()`等函数，不常用。

#### 格式设置

##### 1.设置宽度

可以使用 setw 设置输出的宽度（以字符为单位）。如果输出的内容小于指定宽度，cout 会用空格填充。

```c
#include <iostream>
#include <iomanip>  // 必须包含这个头文件
using namespace std;

int main() {
    int x = 42;
    cout << setw(10) << x << endl;  // 输出宽度为10，数值42会右对齐
    return 0;
}
```

##### 2.设置浮点数格式

可以通过在要输出的数字前面加上 fixed 和 scientific 控制浮点数的显示格式。
fixed 使得输出的浮点数以固定的小数格式显示，不会变成科学计数法。
scientific 则使其以科学计数法显示。

```c
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double pi = 3.14159265358979;
    cout << fixed << setprecision(4) << pi << endl;  // 使用定点格式
    cout << scientific << setprecision(4) << pi << endl;  // 使用科学计数法
    return 0;
}
```

输出：

```c
3.1416
3.1416e+00
```

##### 3.设置精度

单独使用 setprecision 可以控制浮点数输出的有效数字位数。
与 fixed 联合使用可以控制浮点数输出的小数位数。（直接输出一个浮点数默认小数位数是 5 位，用 fixed 修饰后默认输出 6 位小数，用 fixed 和 setprecision 一起修饰可以自由控制小数位数）

```c
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double pi = 3.14159265358979;
    cout << setprecision(4) << pi << endl;  // 保留4位有效数字
    cout << fixed << setprecision(4) << pi << endl;  // 保留4位小数
    return 0;
}
```

输出

```c
3.142
3.1416
```

##### 4.控制输出的填充字符
setfill 可以设置填充字符，用于填充宽度不够的空白部分。

```c
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int x = 42;
    cout << setw(10) << setfill('*') << x << endl;  // 使用 '*' 作为填充字符
    return 0;
}
```

输出

```c
*******42
```

##### 5.对齐方式
C++中的输出默认是右对齐的，使用 left 和 right 可以改变对齐方式

```c
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int x = 42;
    cout << setw(10) << left << x << endl;  // 左对齐输出
    cout << setw(10) << right << x << endl; // 右对齐输出
    return 0;
}
```

输出

```c
42        
    	42
```

##### 6.设置数字的符号

可以使用 showpos 来显示正数的符号，默认情况下，正数不显示符号

```c
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int x = 42;
    int y = -42;
    cout << showpos << x << endl;  // 显示正数的符号
    cout << showpos << y << endl;  // 显示负数的符号
    return 0;
}
```

输出

```+42
-42
```

#### endl和\n

换行有两种方式：

1. 使用endl：插入换行符并刷新输出缓冲区
2. 使用\n：只插入换行符

| 情景                | endl                 | \n           |
| :------------------ | :------------------- | :----------- |
| 少量输出            | 无明显差异           | 无明显差异   |
| 高频循环输出(万次+) | **显著降低性能**     | **性能更高** |
| 实时日志记录        | 确保立即输出（安全） | 可能延迟输出 |

### `cerr`

`cerr`是标准错误流，也是`ostream`类的一个实例，并默认输出设备为显示屏上的命令行终端。它默认与`stderr`同步。

`cerr`是非缓冲的，即插入数据时会立即输出。

#### 用法示例：

```c
char str[] = "File open FAILED!";
cerr << "[Error] " << str;
```

### `clog`
`clog`是标准日志流，也是`ostream`类的一个实例，并默认输出设备为显示屏上的命令行终端。

`clog`是有缓冲的，但具体的刷新条件没有找到资料。实测以下代码是可以输出在屏幕的：

```c
clog << "Failed!";
while(1){}
```

### 总结
标准输出相比输入来说较为简单。需要注意的是`stdout`和`cout`是行缓冲的，而`stderr`和`cerr`是无缓冲的。

---
依照大佬的智慧，原链接：

https://blog.csdn.net/Dr_Myst/article/details/123164599

https://blog.csdn.net/2301_80361697/article/details/144554784

https://blog.csdn.net/weixin_43469047/article/details/83473030

https://www.cnblogs.com/yygsj/p/4996377.html

https://blog.csdn.net/ssopp24/article/details/52893694

---

表 1  cin 输入流对象常用成员方法  
| 成员方法              | 功能说明                                                     |
| --------------------- | ------------------------------------------------------------ |
| `getline(str, n, ch)` | 从输入流中最多读取 `n-1` 个字符到 `str`，遇 `ch`（默认为 `'\n'`）即停；**默认行分隔符是 `'\n'`，而非 `'\0'`**。 |
| `get()`               | 读取**下一个字符**（含空格、换行等）并返回；读取后该字符从流中移除。 |
| `gcount()`            | 返回**上一次** `get` / `getline` / `ignore` / `read` 等实际提取的字符数。 |
| `peek()`              | 仅**查看**下一个字符**不提取**，下次读取仍是该字符。         |
| `putback(c)`          | 把字符 `c`**放回**输入流缓冲区，成为下一个被读取的字符。     |
| `ignore(n, ch)`       | 连续提取并丢弃字符，直到：①已丢弃 `n` 个字符，或②遇到 `ch`（默认 `n=1, ch=EOF`）。 |
| `operator>>`          | 格式化提取：跳过前导空白，读取符合目标类型的数据；返回流对象本身，支持链式调用。 |

---

表 2  cout / cerr / clog 输出流对象常用成员方法  
| 成员方法                         | 功能说明                                                     |
| -------------------------------- | ------------------------------------------------------------ |
| `put(c)`                         | 向流写入**单个字符** `c`。                                   |
| `write(s, n)`                    | 把字符串 `s` 的前 `n` 个字符**原样**写出（不做格式化、不遇 `'\0'` 停）。 |
| `tellp()`                        | 返回当前**输出位置**（从流开头算起的字节偏移）。             |
| `seekp(pos)` / `seekp(off, dir)` | 移动输出指针到**绝对位置** `pos` 或**相对位置** `off`（`dir` 取 `beg/cur/end`）。 |
| `flush()`                        | 强制把缓冲区内容**立即刷到设备**（屏幕、文件等）。           |
| `operator<<`                     | 格式化输出：支持链式写入，自动根据类型选择格式；返回流对象本身。 |

---

表 3 I/O 库头文件

| 头文件       | 提供的核心功能与对象                                         |
| ------------ | ------------------------------------------------------------ |
| `<iostream>` | 定义标准流对象：<br>`cin`（标准输入）、`cout`（标准输出）、<br>`cerr`（非缓冲标准错误）、`clog`（缓冲标准错误）。 |
| `<iomanip>`  | 提供参数化流操纵器（如 `setw`、`setprecision` 等），用于格式化控制标准 I/O。 |
| `<fstream>`  | 提供用户控制的文件处理功能（如 `ifstream`、`ofstream`、`fstream` 类），支持文件读写。 |



















---

之后会按照这个教程来刷题：

https://leetcode.cn/discuss/post/3141566/ru-he-ke-xue-shua-ti-by-endlesscheng-q3yd/

[代码随想录](https://programmercarl.com/数组理论基础.html)

争取每天有记录，每天有收获