## 类和面向对象

提及到C++我们总会抛出一句话：C语言是面向过程的，C++是基于面向对象的。那么到底什么是面向过程什么是面向对象呢？二者又有什么区别呢？

**面向过程**（Procedural Programming）： 面向过程编程更侧重于步骤和函数的组合来解决问题。程序被设计为一系列有序的步骤，每个步骤对应一个函数或子程序，这些函数直接操作数据。面向过程编程不强调对象的概念，而是以数据为中心，通过函数来处理数据。

面向对象（Object-Oriented Programming, OOP）是一种编程范式，它基于“对象”的概念，将数据和操作数据的方法组织在一起。在面向对象编程中，对象是类的实例，类定义了对象的属性（数据成员）和行为（方法）。对象可以互相通信，通过调用彼此的方法来完成任务。面向对象的四个核心原则是封装、继承、多态和抽象。

面向对象的三大特性：

**封装**：隐藏对象的内部细节，只对外提供接口进行交互，保护数据的安全性。
**继承**：允许创建一个新类（子类）作为现有类（父类）的扩展，继承其属性和方法。
**多态**：同一方法可以根据调用它的对象类型表现出不同的行为。

面向对象与面向过程的区别：

编程思路：面向对象是基于类和对象，通过对象之间的交互实现功能；面向过程是通过函数调用来完成任务序列。
封装性：面向对象封装的是数据和操作数据的方法，而面向过程主要封装的是功能逻辑。
结构与复用：面向对象支持继承和多态，使得代码更容易复用和扩展；面向过程的复用主要依赖函数和模块。

复杂性管理：面向对象更适合处理复杂的系统，因为它能更好地模拟现实世界中的实体和关系；面向过程则适用于简单的、线性的任务。

```cpp
class 类名{
访问修饰符:
          // 成员变量，表示类的属性， 定义方式和变量的定义一样
      // 成员方法，表示类的行为， 定义方式和方法的定义一样
}; // 分号结束一个类
```

C++使用`class`定义一个类，并在类中定义成员变量和成员方法。

大括号内被称为类体或类空间，是定义和声明类成员的地方。关键字 **public、private、protected** 是类成员访问修饰符，限定了类成员的访问权限。**大括号后要有分号**。

- `public`: 被修饰的成员在类的内部、派生类（子类）的内部和类的对象外部都可以访问。
- `private`: 被修饰的成员只能在定义该成员的类的内部访问。
- `protected`: 被修饰的成员只能在定义该成员的类的内部以及派生类汇总访问。

| 访问权限      | 类内部   | 派生类     | 类外部     | 友元函数/类 |
| :------------ | :------- | :--------- | :--------- | :---------- |
| **public**    | ✅ 可访问 | ✅ 可访问   | ✅ 可访问   | ✅ 可访问    |
| **protected** | ✅ 可访问 | ✅ 可访问   | ❌ 不可访问 | ✅ 可访问    |
| **private**   | ✅ 可访问 | ❌ 不可访问 | ❌ 不可访问 | ✅ 可访问    |

| 继承方式          | 基类public | 基类protected | 基类private |
| :---------------- | :--------- | :------------ | :---------- |
| **public继承**    | public     | protected     | 不可访问    |
| **protected继承** | protected  | protected     | 不可访问    |
| **private继承**   | private    | private       | 不可访问    |

类成员包括两类，分别是成员变量和成员函数：

- **成员变量**（又称为数据成员）表示类的属性，可以是整型、浮点型、字符型、数组、[指针](https://c.biancheng.net/c/80/)和引用等，也可以是对象；
- **成员函数**（又称为方法）表示类的行为。

比如下面的示例，`public`定义成员变量和成员方法的权限，后面定义了成员变量`myAttribute`和成员方法`myMethod`。

```cpp
class MyClass {
public:
    // 成员变量
    int myAttribute;
    // 成员方法
    void myMethod() {
        // 方法实现
    }
};

int main() {
    // 创建对象
    MyClass obj;
    // 访问属性
    obj.myAttribute = 42;
    // 调用方法
    obj.myMethod();
    return 0;
}
```

> C++中struct和class的区别是什么？
>
> C++需要兼容C语言，所以C++中struct可以当成结构体使用。另外C++中struct还可以用来定义类。和class定义类是一样的，区别是struct定义的类默认访问权限是public，class定义的类默认访问权限是private。在继承和模板参数列表位置，struct和class也有区别。在继承中，使用struct和class关键字指定基类时有不同的含义。如果使用struct继承，则默认是public继承；如果使用class继承，则默认是private继承。至于再模板上面的区别，我们再模板部分讲。

## 类的定义和实现

CPerson 类中声明了类的成员，下面介绍如何定义类中的方法（即成员函数）。

1) 将类的成员函数都定义在类体内。例如，以下代码都在 Person.h 头文件内，类的成员函数都定义在类体内。

   [需注意：**成员函数如果在类中定义，编译器可能会将其当成内联函数处理**]

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
class CPerson //定义 CPerson 类
{
public:
    int m_index;
    short m_shAge;

    short getAge()  //定义 getAge()，表示获取员工工龄
    {
        return m_shAge;
    }
    //...
};
```

2) 将类体内成员函数的实现放在类体外，此时需要使用域限定符“::”标识该方法属于哪个类。放在类体内和类体外定义的效果是一样的。

```c
class CPerson //定义 CPerson 类，声明 4 个成员变量和 8 个成员函数
{
public:
    int m_index;
    short m_shAge;

    short getAge();
    int setAge(short sAge);
    // 省略其他成员函数的声明代码
};

// CPerson 类成员函数的实现部分
short CPerson::getAge()  //定义 getAge()，在类体外定义要使用域限定符“::”
{
    return m_shAge;
}
int CPerson::setAge(short sAge)  //定义 setAge()，在类体外定义要使用域限定符“::”
{
    m_shAge=sAge;
    return 0;
}
// 省略其他成员函数的实现代码
```

除此以外，C++ 中还可以将函数的声明和定义放在不同的文件内。一般在头文件中放入函数的声明部分，在实现文件中放入成员函数的实现部分。同样，也可以将类的定义放在头文件中，将类的成员函数的实现放在实现文件内。存放类的头文件和实现文件最好和类名相同或相似。

例如，将 CPerson 类的声明部分放在 Person.h 文件内，程序代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
class CPerson  //定义 CPerson 类，声明 4 个成员变量和 8 个成员函数
{
public:
    int m_index;
    char m_cName[25];
    short m_shAge;
    double m_dSalary;
    short getAge();
    int setAge(short sAge);
    int getIndex();
    int setIndex(int index);
    char *getName();
    int setName(char cName[25]);
    double getSalary();
    int setSalary(double dSalary);
};
```

将 CPerson 类的实现部分放在 Person.cpp 文件内，程序代码如下：

```  c
#include "Person.h"  //CPerson 类成员函数的实现部分
short CPerson::getAge()
{
    return m_shAge;
}
int CPerson::setAge(short sAge)
{
    m_shAge=sAge;
    return 0;
}
//省略其他成员函数的实现代码
```

整个工程的所有文件如下图所示：



![img](https://c.biancheng.net/uploads/allimg/250703/2-250F31H5533Z.gif)
图 2 工程所有文件

> 注意，类的 .h 文件名不需要和 .cpp 文件名相同，但是在 .cpp 文件中包含头文件时，一定要和 .h 文件名一致。

关于类的实现，有以下两点说明：

1) 类的成员变量需要初始化，成员函数还需要添加实现代码。另外，类的成员变量不能在类的声明中初始化。例如，下面的代码将无法通过编译：

```c
class CPerson
{
    int m_index=1;  //错误写法，不能在类的声明中初始化
    char m_cName[25]="Mary";  //错误写法，不能在类的声明中初始化
    short m_shAge=22;  //错误写法，不能在类的声明中初始化
    double m_dSalary=1700.00;  //错误写法，不能在类的声明中初始化
    short getAge();
    int setAge(short sAge);
    //省略其他成员函数的声明代码
};
```

2) 空类是 C++ 中最简单的类，通常用来占位。其声明方式如下：

```c
class CPerson{};
```

程序开发中，空类表示此处暂不定义，后续根据需要再定义其类成员及方法实现。

## 类的实例化

```c
// 类中既有成员变量，又有成员函数
class A1 {
public:
	void f1() {}
private:
	int _a;
};
// 类中仅有成员函数
class A2 {
public:
	void f2() {}
};
// 类中什么都没有---空类
class A3
{};
int main()
{
	A1 a1;
	A2 a2;
	A3 a3;
 
	cout << "A1:" <<sizeof(a1)<< " A2:" <<sizeof(a2)<< " A3:" <<sizeof(a3)<< endl;
	return 0;
}
```

```c
A1:4 A2:1 A3:1
```

一个类的大小，实际就是该类中”成员变量”之和，与成员函数无关。因为成员变量（属性）是存储在对象实例的内存空间中的，成员函数存放在公共的代码段。当然要注意内存对齐

注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。

在C++中，即使是空的类，也可以被实例化。每个实例（对象）在内存中都需要一个独一无二的地址，以便程序能够区分它们。如果空类的大小为0，那么实例化多个对象时，它们在内存中的地址可能会重叠，从而无法区分这些实例。

内存对齐[【C语言高阶篇】结构体 —— 什么是内存对齐？-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2374061)

### 对象的声明和引用

类是一种数据类型，用户定义类后，即可通过类名声明对象。语法格式如下：

```c
类名 对象名
```

例如，使用前面定义的 CPerson 类声明对象：

```c
CPerson p;  //声明对象 
pCPerson p1,p2,p3.  //声明 3 个对象 p1、p2、p3
```

对象的引用方式有两种：使用成员运算符“.”和使用指向运算符“->”。

1) 使用“.”运算符引用成员变量和成员函数，语法形式如下：

```c
对象名.成员名
对象名.成员名（参数表）  //参数表
```

例如，可通过 p.m_index、p.getAge() 引用类 p 中的成员。

2) 对象数组、对象指针和引用形式的对象，需要使用指向运算符“->”运算符进行引用。例如，声明一个对象指针 p，使其指向对象 m_iIndex，代码如下：

```c
CPerson *p;
p->m_iIndex;
```

下面两种引用成员变量的形式是等价的：

```
对象指针名->数据成员名
(*对象指针名).数据成员名
```

同样，下面两种引用成员函数的形式也是等价的：

```
对象指针名->成员函数名(参数表)
(*对象指针名).成员函数名(参数表)
```

例如，可通过 (*p).m_iIndex 或 p->m_iIndex 引用类 p 中的成员。

【实例】在本实例中，利用前文声明的 CPerson 类定义对象，然后使用该对象引用其成员。程序代码如下：

```c
#include <iostream>
#include "Person.h"
using namespace std;
int main()
{
    int iResult=-1;
    CPerson p;  //声明对象 p，属于 CPerson 类
    iResult=p.setAge(25);  //引用 p.setAge()，设置工龄
    if(iResult>=0)
        cout << "m_shAge is:" << p.getAge() << endl;  //引用 p.setAge()，输出工龄
    iResult=p.setIndex(0);  //引用 p.setIndex()，设置员工编号
    if(iResult>=0)
        cout << "m_index is:" << p.getIndex() << endl;  //引用 p.getIndex()，输出员工编号
    char bufTemp[]="Mary";
    iResult=p.setName(bufTemp);  //引用 p.setName()，设置姓名
    if(iResult>=0)
        cout << "m_cName is:" << p.getName() << endl;  //引用 p.getName()，输出姓名
    iResult=p.setSalary(1700.25);  //引用 p.setSalary()，设置薪资
    if(iResult>=0)
        cout << "m_dSalary is:" << p.getSalary() << endl;  //引用 p.getSalary()，输出薪资
}
```

程序中首先使用 CPerson 类定义对象 p，然后引用类中的成员函数。p.setAge(25) 引用类中的 setAge() 成员函数，传递实参，设置员工工龄。函数返回值赋给 iResult 变量，并通过 iResult 判断函数 setAge() 为数据成员赋值是否成功，如果成功，使用 p.getAge() 得到赋值数据并显示输出。

之后使用对象 p 依次引用成员函数 setIndex()、setName()和setSalary()，然后通过对 iResult 变量的判断，决定是否引用成员函数 getIndex()、getName() 和 getSalary()。

### this指针

先看2个实例：

```c
#include <iostream>
 
class MyClass {
private:
    int value;
 
public:
    void setValue(int value) {
        this->value = value;
    }
 
    void printValue() {
        std::cout << "Value: " << this->value << std::endl;
    }
};
 
int main() {
    MyClass obj;
    obj.setValue(42);
    obj.printValue();
 
    return 0;
}
//输出   Value:42
```

```c
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"调用构造函数。" << endl;
         length = l;
         breadth = b;
         height = h;
      }
      double Volume()
      {
         return length * breadth * height;
      }
      int compare(Box box)
      {
         return this->Volume() > box.Volume();
      }
   private:
      double length;     // 宽度
      double breadth;    // 长度
      double height;     // 高度
};
 
int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2
 
   if(Box1.compare(Box2))
   {
      cout << "Box2 的体积比 Box1 小" <<endl;
   }
   else
   {
      cout << "Box2 的体积大于或等于 Box1" <<endl;
   }
   return 0;
}
/*
调用构造函数。
调用构造函数。
Box2 的体积大于或等于 Box1
*/
```

---

```c
class Date
{
public:
    void Init(int year, int month, int day)
    {
        _year = year;
        _month = month;
        _day = day;
    }
    void Print()
    {
        cout <<_year<< "-" <<_month << "-"<< _day <<endl;
    }
private:
    int _year; // 年
    int _month; // 月
    int _day; // 日
    int a;
};
int main()
{
    Date d1, d2;
    d1.Init(2022,1,11);
    d2.Init(2022, 1, 12);
    d1.Print();
    d2.Print();
    return 0;
}
```

Date类中有 Init 与 Print 两个成员函数，函数体中没有关于不同对象的区分，那当d1调用 Init 函数时，该函数是如何知道应该设置d1对象，而不是设置d2对象呢？

> C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有“成员变量”的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。

1. this指针的类型：类类型* const，即成员函数中，不能给this指针赋值。

2. 只能在“成员函数”的内部使用

3. this指针本质上是“成员函数”的形参，当对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。

4. this指针是“成员函数”第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递

![img](https://i-blog.csdnimg.cn/direct/22890274dfdc4026a14a2519057d696c.png)

This指针有可能是nullptr吗？ 可能，但一般情况下不为空。

![img](https://i-blog.csdnimg.cn/direct/2ed5c94a95874e2d9d96075243d63ea1.png)

这里为什么可以，且能跑，是因为当程序编译后，成员函数的地址即已经确定。另外，C++只关心你的指针类型，不关心指针指向的对象是否有效，C++要求程序员自己保证指针的有效性。nullptr对象调用成员函数时，只要不访问此对象独有的内存部分（成员变量），则程序正常运行，因为不会使用this，一旦访问此对象的成员变量，则程序崩溃。 如下：

![img](https://i-blog.csdnimg.cn/direct/215276ef3c8942958fa95a428384ea26.png)

This指针存在哪里 
        this指针是在C++类中的一个特殊指针，它指向当前对象的地址。在类的成员函数中，可以使用this指针来访问当前对象的成员变量和成员函数。在C++中，每个非静态成员函数都隐含地包含一个this指针。即this是个形参，存放在栈区中，或叫ecx寄存器，上述图片可以直接展现编译器将d1的地址存放到寄存器中。

### 类的六个默认成员函数

如果一个类中什么成员都没有，简称为空类。 空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。 默认成员函数：用户没有显式实现，编译器会生成的成员函数称为默认成员函数。

#### 构造函数
​        构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，以保证每个数据成 员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次。构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象，而是初始化对象。

特征如下：

1. 函数名与类名相同。

2. 无返回值。

3. 对象实例化时编译器自动调用对应的构造函数。

4. 构造函数可以重载。

```c
 class Date
 {
public:
 // 1.无参构造函数
    Date()
    {}
 // 2.带参构造函数
    Date(int year, int month, int day)
    {
         _year = year;
         _month = month;
         _day = day;
    }
 private:
     int _year;
     int _month;
     int _day;
 };
 void TestDate()
 {
        Date d1; // 调用无参构造函数
        Date d2(2015, 1, 1); // 调用带参的构造函数
// 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明
// 以下代码的函数：声明了d3函数，该函数无参，返回一个日期类型的对象
// warning C4930: “Date d3(void)”: 未调用原型函数(是否是有意用变量定义的?)
        Date d3();
 }
```

5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。

```c
class Date
{
public:
	
	// 如果用户显式定义了构造函数，编译器将不再生成
   Date(int year, int month, int day)
	{
	_year = year;
	_month = month;
	_day = day;
	}
	
	void Print()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
	int _year;
int _month;
int _day;
 };
 int main()
 {
	 // 将Date类中构造函数屏蔽后，代码可以通过编译，因为编译器生成了一个无参的默认构造函数
	// 将Date类中构造函数放开，代码编译失败，因为一旦显式定义任何构造函数，编译器将不再生成
		 // 无参构造函数，放开后报错：error C2512: “Date”: 没有合适的默认构造函数可用
		 Date d1;
		 Date d2(111, 11, 1);//// 将Date类中构造函数放开后，这样才是对的
	 return 0;
 }
```

6. 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：无参 构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。
7. 构造函数不能被`const`修饰
8. 构造函数不能是虚函数

注：注意：C++11 中针对内置类型成员不初始化的缺陷，又打了补丁，即：内置类型成员变量在类中声明时 可以给默认值。

**初始化列表**

初始化列表是构造函数的一部分，或者说，加上初始化列表才是完整的构造函数。因为初始化列表是真正的对成员变量进行初始化，而构造函数体中是赋值。初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟一个放在括号中的初始值或表达式。



1. 每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)

2. 类中包含以下成员，必须放在初始化列表位置进行初始化：
        引用成员变量
        const成员变量
        自定义类型成员(且该类没有默认构造函数时)

3. 尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。

4. 成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关

#### 析构函数

与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成 的。而对象在销毁时会自动调用析构函数，完成对象中资源的清理工作。

特征：

1. 析构函数名是在类名前加上字符 ~。

2. 无参数无返回值类型。

3. 一个类只能有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。注意：析构函数不能重载

4. 对象生命周期结束时，C++编译系统系统自动调用析构函数

5. 编译器生成的默认 析构函数，对自定类型成员调用它的析构函数。

```c
 class Time
 {
 public:
     ~Time()
     {
         cout << "~Time()" << endl;
     }
 private:
    int _hour;
    int _minute;
    int _second;
 };
 class Date
 {
 private:
     // 基本类型(内置类型)
     int _year = 1970;
     int _month = 1;
     int _day = 1;
 // 自定义类型
    Time _t;
 };
 int main()
 {
     Date d;
     return 0;
 }
 // 程序运行结束后输出：~Time()
 // 在main方法中根本没有直接创建Time类的对象，为什么最后会调用Time类的析构函数？
// 因为：main方法中创建了Date对象d，而d中包含4个成员变量，其中_year, _month, _day三个是内置类型成员，销毁时不需要资源清理，最后系统直接将其内存回收即可；而_t是Time类对象，所以在d销毁时，要将其内部包含的Time类的_t对象销毁，所以要调用Time类的析构函数。但是：main函数中不能直接调用Time类的析构函数，实际要释放的是Date类对象，所以编译器会调用Date类的析构函数，而Date没有显式提供，则编译器会给Date类生成一个默认的析构函数，目的是在其内部调用Time类的析构函数，即当Date对象销毁时，要保证其内部每个自定义对象都可以正确销毁
// main函数中并没有直接调用Time类析构函数，而是显式调用编译器为Date类生成的默认析构函数
// 注意：创建哪个类的对象则调用该类的析构函数，销毁那个类的对象则调用该类的析构函数
```

6. 如果类中没有申请资源时，析构函数可以不写，直接使用编译器生成的默认析构函数，比如Date类；有 资源申请时（malloc，new...），一定要写，否则会造成资源泄漏，比如Stack类。

#### 拷贝构造函数
拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型 对象创建新对象时由编译器自动调用。

特征：

1. 拷贝构造函数是构造函数的一个重载形式。

2. 拷贝构造函数的参数只有一个且必须是类类型对象的引用，使用传值方式编译器直接报错，因为会引发 无穷递归调用。

```c
class Date
 {
 public:
    Date(int year = 1900, int month = 1, int day = 1)
    {
        _year = year;
        _month = month;
        _day = day;
    }
 
    // Date(const Date& d)   // 正确写法
    Date(const Date d)   // 错误写法：编译报错，会引发无穷递归
    {
        _year = d._year;
        _month = d._month;
        _day = d._day;
    }
 private:
    int _year;
    int _month;
    int _day;
 };
 int main()
 {
     Date d1;
     Date d2(d1);
     return 0;
 }
```

3. 若未显式定义，编译器会生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成 拷贝，这种拷贝叫做浅拷贝，或者值拷贝。即:将对象中内容原封不动的拷贝到新对象中。问题:如果原对象中涉及到资源管理，那么新对象和原对象共用的就是同一份资源，在进行赋值或者析构时会造成内存泄漏戏者程序崩溃。

```c
// 这里会发现下面的程序会崩溃掉？这里就需要我们以后讲的深拷贝去解决。
typedef int DataType;
 class Stack
 {
 public:
     Stack(size_t capacity = 10)
     {
         _array = (DataType*)malloc(capacity * sizeof(DataType));
         if (nullptr == _array)
         {
             perror("malloc申请空间失败");
             return;
         }
         _size = 0;
         _capacity = capacity;
     }
 void Push(const DataType& data)
 {
     // CheckCapacity();
     _array[_size] = data;
     _size++;
 }
 ~Stack()
 {
     if (_array)
     {
        free(_array);
         _array = nullptr;
         _capacity = 0;
         _size = 0;
     }
 }
 private:
     DataType *_array;
     size_t _size;
     size_t _capacity;
 };
 int main()
 {
     Stack s1;
     s1.Push(1);
     s1.Push(2);
     s1.Push(3);
     s1.Push(4);
     Stack s2(s1);
     return 0;
 }
```

![img](https://i-blog.csdnimg.cn/direct/63f0788fc4314f5bbe6881e09ccd3d8e.png)

 类中如果没有涉及资源申请时，拷贝构造函数是否写都可以；一旦涉及到资源申请时，则拷贝构 造函数是一定要写的，否则就是浅拷贝. 

4. 在编译器生成的默认拷贝构造函数中，内置类型是按照字节方式直接拷贝的，而自定义类型是调 用其拷贝构造函数完成拷贝的

#### 赋值运算符重载

 **运算符重载**

> 函数名字为：关键字operator后面接需要重载的运算符符号。
>
> 函数原型：返回值类型 operator操作符(参数列表

**运算符重载和函数重载的区别？** 

**函数重载**指的是在同一个作用域下，一组函数的**函数名相同**，但是形参列表(类型、顺序、个数)不同，这样的函数就构成了函数重载。**注意:函数返回值类型和函数重载无关**

> c语言不支持函数重载的原因
> c语言进行函数修饰时只用到了函数名的信息，函数名相同修饰之后也是一样的名字，对于同名函数编译器没办法区分，会认为函数重定义，所以不支持函数重载。
>
> C++函数重载的底层原理
> 对于同名函数，C++根据函数名和参数列表对函数名进行修饰，修饰之后同名的函数编译器也能进行区分。
> 例如：g++的函数修饰规则是
> _Z+函数名字符个数+函数名+形参列表类型首字母
>
> 因此，同名函数如果只有返回值类型不相同，修饰之后编译器还是没办法区分，会认为函数重定义。

运算符重载的注意事项：

1. 不能通过连接其他符号来创建新的操作符：比如operator@

2. 重载操作符必须有一个类类型参数

3. 用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不 能改变其含义

作为类成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this

4. .*  ::  sizeof  ?:  . 注意以上5个运算符不能重载。

```c
class Date
 { 
public:
    Date(int year = 1900, int month = 1, int day = 1)
    {
        _year = year;
        _month = month;
        _day = day;
    }  
    //做为类成员函数时
    // bool operator==(Date* this, const Date& d2)
    // 这里需要注意的是，左操作数是this，指向调用函数的对象
    bool operator==(const Date& d2)
     {
         return _year == d2._year;
         && _month == d2._month
         && _day == d2._day;
     }  
//private:
    int _year;
    int _month;
    int _day;
 };
 // 全局的operator==
// 这里会发现运算符重载成全局的就需要成员变量是公有的，那么问题来了，封装性如何保证？
// 这里其实可以用友元解决，或者干脆重载成成员函数。
bool operator==(const Date& d1, const Date& d2)
 {
    return d1._year == d2._year
        && d1._month == d2._month
        && d1._day == d2._day;
 }
 
void Test ()
 {
    Date d1(2018, 9, 26);
    Date d2(2018, 9, 27);
    cout<<(d1 == d2)<<endl;
 }
```

**赋值运算符重载** 

​     1. 赋值运算符重载格式

> 参数类型：const T&，传递引用可以提高传参效率
>
> 返回值类型：T&，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值检测是否自己给自己赋值
>
> 返回*this ：要复合连续赋值的含义

```c
Date& operator=(const Date& d) {
    if (this != &d) {
        _year = d._year;
        _month = d._month;
        _day = d._day;
    }
    return *this;
}
```

2. 赋值运算符只能重载成类的成员函数不能重载成全局函数 .赋值运算符重载成全局函数，注意重载成全局函数时没有this指针了。

原因：赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现一个全局的 赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载冲突了，故**赋值运算符重载只能是类的成员函数**

3. 用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。注意：内置类 型成员变量是直接赋值的，而自定义类型成员变量需要调用对应类的赋值运算符重载完成赋值。

4. 编译器生成的默认赋值运算符重载函数已经可以完成字节序的值拷贝（浅拷贝）了，还需要自己实现吗？当然

   ![img](https://i-blog.csdnimg.cn/direct/8fb0ddbcf69047d8913e1da7e277291e.png)

如果类中涉及到资源管理时，用户必须要显式提供赋值运算符重载，否则可能会造成内存泄漏或者运行时崩溃，用户一般是按照深拷贝方式提供的 。

这里只讲到了，构造函数，析构函数，拷贝构造函数，赋值运算符重载。还有两个是普通对象取地址重载和const对象去地址重载，只不过这两个很少自己写，编译器默认生成的完全够用了。

### const成员

**将const修饰的“成员函数”称之为const成员函数**，const修饰类成员函数，**实际修饰该成员函数隐含的this 指针**，表明在该成员函数中不**能对类的任何成员进行修改**。除非该变量被nutable修饰。且该成员函数只能调动const成员函数，不能调动非const成员函数。

![img](https://i-blog.csdnimg.cn/direct/51c36d8363524ef88232ef31414d824c.png)

const修饰的成员变量不能再成员函数中被修改，且必须再类初始化列表中初始化。

1. const关键字的作用？

   const 可以用来定义常量，即一旦初始化后就不能被修改的值。const 可以用来修饰指针，表明指针所指向的内容是常量（指向常量的指针）或者指针本身是常量（常量指针）或者指向常量的常量指针。const 可以用来修饰传入参数，表明函数内部不会修改这些参数的值。

2. const修饰的常量和宏常量的区别？
   (1) 编译器处理方式不同：　　define宏是在预处理阶段展开。　　const常量是编译运行阶段使用。

   (2) 类型和安全检查不同：define宏没有类型，不做任何类型检查，仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查。

   (3) 存储方式不同：　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）　const常量会在内存中分配(可以是堆中也可以是栈中)。

3. const对象可以调用非const成员函数吗？

   答案是不可以。const对象只能调用const成员函数。非const成员函数可能会修改对象的成员变量，而const对象保证在其生命周期内其状态（即成员变量的值）不会改变。因此，从逻辑上讲，不允许const对象调用可能会改变其状态的非const成员函数。

4. 非const对象可以调用const成员函数吗？

   答案是可以。非const对象可以调用任何成员函数，包括const成员函数。const成员函数承诺不会修改任何成员变量的值，因此，非const对象调用const成员函数是安全的。

5. const成员函数内可以调用其它的非const成员函数吗？

   答案是不可以，直接调用是不允许的。由于const成员函数承诺不会修改任何成员变量的值，因此它不能调用可能修改成员变量的非const成员函数。如果需要在const成员函数内部调用非const成员函数，你通常需要重新考虑设计，因为这通常违反了const成员函数的目的。不过，一种可能的解决方案是通过非const成员函数或其他机制（如友元函数或静态成员函数）间接实现。

6. 非const成员函数内可以调用其它的const成员函数吗？

   答案是可以。非const成员函数可以调用const成员函数，因为const成员函数不会修改任何成员变量的值，因此从非const成员函数内调用它们是安全的。这种调用是常见的，尤其是在非const成员函数需要访问或处理数据，但又不想修改数据时。

### 静态成员函数 
声明为static的类成员称为类的静态成员，用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。静态成员变量一定要在类外进行初始化。

特性：

1. 静态成员为所有类对象所共享，不属于某个具体的对象，存放在静态区

2. 静态成员变量必须在类外定义，定义时不添加static关键字，类中只是声明

3. 类静态成员即可用 类名::静态成员 或者 对象.静态成员 来访问

4. 静态成员函数没有隐藏的this指针，不能访问任何非静态成员

5. 静态成员也是类的成员，受public、protected、private 访问限定符的限制

静态成员变量：

1. 静态成员变量不能在初始化列表位置初始化，必须在类外进行初
   始阿化，在类外初始阿化时必须要加类名::，类中只是声明
2. 静态成员变量是类的属性，不属于某个具体的对象，是类所有对
   象共享的
3. 不存在在具体的对象中，因此不会影响sizeof的结果
4. 可以通过对象.静态成员名，也可以通过类名::静态成员变量名方
   式访问
5. 在程序启动时，就完成了对静态成员变量的初始化工作

静态成员函数：

1. 静态成员函数没有this指针
2. 静态成员函数中不能直接访问非静态成员变量，因为所有非静态成员变量都是通过this指针访问的
3. 静态成员函数中不能调用普通成员函数。因为静态成员函数没有this指针，而普通成员函数有this指针，导致参数个数不匹配。非静态成员函数可以调用类的静态成员函数
4. 静态成员函数不能被this修饰
5. 静态成员函数不能是虚函数。因为虚函数通过this指针隐式地访问对象的成员。由于静态成员函数没有this指针，因此它们无法以虚函数的方式工作。
6. 既可以通过对象，也可以通过类名::方式访问 

### 友元

友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。友元分为：**友元函数**和**友元类**

#### 友元函数

我们现在类中现在尝试去重载operator<<后发现：

```c
class Date
{
public:
	Date(int year, int month, int day)
		: _year(year)
		, _month(month)
		, _day(day)
	{}
	ostream& operator<<(ostream& _cout)
	{
		_cout << _year << "-" << _month << "-" << _day << endl;
		return _cout;
	}
private:
	int _year;
	int _month;
	int _day;
};
 
int main()
{
	Date d1(2024,8,17);
	d1 << cout;//等于这种写法d1.operator<<(cout);
	//不符合常规调用：cout<<d1;
	return 0;
}
```

若要使用常规调用：**cout<<d1。**那么cout需要是第一个形参对象，但是若是operator<<重载为成员函数，第一个参数又必须时This指针.所以要将operator<<重载成全局函数。但又会导致类外没办法访问成员，此时就需要友元来解决。operator>>同理。如下：

```c
#include <iostream>
using namespace std;

class Date {
    friend ostream& operator<<(ostream& _cout, const Date& d);

public:
    Date(int year, int month, int day)
        : _year(year), _month(month), _day(day) {}

private:
    int _year;
    int _month;
    int _day;
};

ostream& operator<<(ostream& _cout, const Date& d) {
    _cout << d._year << "-" << d._month << "-" << d._day;
    return _cout;
}

int main() {
    Date d1(2024, 8, 17);
    cout << d1; // 等价于 operator<<(cout, d1)
    return 0;
}
```

从上面我们可以看到。友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。

特性：

1. 友元函数可访问类的私有和保护成员，但不是类的成员函数

2. 友元函数不能用const修饰
3. 友元函数可以在类定义的任何地方声明，不受类访问限定符限制一个函数可以是多个类的友元函数
4. 友元函数的调用与普通函数的调用原理相同

#### 友元类

友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。
 特性：

1. 友元关系是单向的，不具有交换性。

   比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。

2. 友元关系不能传递

   如果B是A的友元，C是B的友元，则不能说明C时A的友元。

3. 友元关系不能继承。

```c
class Time
{
    friend class Date; // 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成
员变量
public:
    Time(int hour = 0, int minute = 0, int second = 0)
    : _hour(hour)
    , _minute(minute)
    , _second(second)
    {}
private:
    int _hour;
    int _minute;
    int _second;
};
class Date
{
public:
    Date(int year = 1900, int month = 1, int day = 1)
    : _year(year)
    , _month(month)
    , _day(day)
    {}
    void SetTimeOfDate(int hour, int minute, int second)
    {
    // 直接访问时间类私有的成员变量
        _t._hour = hour;
        _t._minute = minute;
        _t._second = second;
    }
private:
    int _year;
    int _month;
    int _day;
    Time _t;
}
```

### 内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。

下面是一个实例，使用内联函数来返回两个数中的最大值：

```c
#include <iostream>
 
using namespace std;

inline int Max(int x, int y)
{
   return (x > y)? x : y;
}

// 程序的主函数
int main( )
{

   cout << "Max (20,10): " << Max(20,10) << endl;
   cout << "Max (0,200): " << Max(0,200) << endl;
   cout << "Max (100,1010): " << Max(100,1010) << endl;
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
Max (20,10): 20
Max (0,200): 200
Max (100,1010): 1010
```

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

1. 在内联函数内不允许使用循环语句和开关语句；

2. 内联函数的定义必须出现在内联函数第一次调用之前；

3. 类结构中所在的类说明内部定义的函数是内联函数。

## 封装

将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外**公开接口**来和**对象**进行交互。封装本质上是一种管理，让用户更方便使用类。

封装是面向对象的三大特性之一，封装的主要目的是为了保证数据的安全性，我们假设有一个`Circle`类，它具有半径这个属性。

```cpp
class Circle {
public:
    // 成员变量
    int radius;
};
```

然后我们创建一个圆对象

```cpp
Circle circe; // 创建一个对象
```

创建对象之后，外部代码可以直接访问和修改半径，甚至将其设置为负数，这样的设计显然是不合理的。

```cpp
// 外部代码没有经过验证可以直接访问和修改半径
circle.radius = 10
```

为了防止这些问题的发生，我们可以通过封装隐藏对象中一些不希望被外部所访问到的属性或方法，具体怎么做呢？可以分为两步：

- 将对象的属性名，设置为`private`，只能被类所访问
- 提供公共的`get`和`set`方法来获取和设置对象的属性

```cpp
class Circle {
// 私有属性和方法
private:
    int radius;  // 将圆的半径设置为私有的
// 公有属性和方法
public:
      // setXX方法设置属性
    void setRadius(int r) {
          radius = r;
    }
        // getXXX方法获取属性
    int getRadius() {
        return radius;
    }
};
```

使用封装，我们隐藏了类的一些属性，具体的做法是使用`get`方法获取属性，使用`set`方法设置属性，如果希望属性是只读的，则可以直接去掉`set`方法，如果希望属性不能被外部访问，则可以直接去掉`get`方法。此外我们还可以在读取属性和修改属性的同时做一些其他的处理，比如如下的操作：

```cpp
void setRadius(int r) {
      // 对输入的半径进行验证，只有半径大于0，才进行处理
    if (r >= 0) {
        radius = r;
    } else {
        cout << "半径不能为负数" << endl;
    }
}
```

## 构造函数

在学习继承之前，我们先来复习一下构造函数的知识，类的构造函数和之前结构体的构造函数类似，用于初始化对象的成员变量，构造函数与类同名，没有返回类型，并且在对象创建时自动调用。其基本语法包括：

- 函数名：与类名相同
- 参数列表：可以有零个或多个参数，用于在创建对象时传递初始化信息。
- **函数体：** 用于执行构造函数的初始化逻辑。

下面我们还以`Person`类作为示例，包含一个默认构造函数和带参数的构造函数。

> `const string& personName`表示对`string`类型对常量引用，你可以传递字符串参数，但是不能在函数中修改这个参数的值。

```cpp
class Person {
private:
  int age;
  string name;
public:
  // 默认构造函数
  Person() {
    age = 20;
    name = "Tom"
  }
  // 带参数的构造函数
  Person(int personAge, const string& personName) {
    age = personAge;
    name = personName
  }
}
int main() {
    // 使用默认构造函数创建对象
    Person person1;
 
    // 使用带参数的构造函数创建对象
    Person person2(20, "Jerry");
  
    return 0;
}
```

此外，还有构造函数的成员初始化列表写法，这种写法允许在进入构造函数主体之前对类成员进行初始化，比如下面的示例。

```cpp
Person(int personAge, const string& personName) : age(personAge), name(personName) {
}
```

在上面的代码中， `Person` 类的构造函数接受一个 `string` 类型的参数 `persnName`和一个`int`类型的参数`personAge`，并通过成员初始化列表初始化了 成员变量。在这里，`: age(personAge), name(personName)` 表示将 `personAge` 的值赋给 `age` 成员变量, 将 `personName` 的值赋给 `name` , 从而完成了成员变量初始化。

## 继承

在对象中，总有一些操作是重复的，比如说`Person`类具有姓名、身高、年龄等特征，并具有一些行走、吃饭、睡觉的方法，而我们要实现一个`Teacher`类，`Teacher`首先也是一个人，他也具备人的特征和方法，那我们是不是也应该用代码去实现这些特征和方法呢，这就势必会产生一些重复的代码。

因此，我们可以采用“继承”的方式使得一个类获取到其他类中的属性和方法。在定义类时，可以在类名后指定当前类的父类（超类), 子类可以直接继承父类中的所有属性和方法，从而避免编写重复性的代码，此外我们还可以对子类进行扩展。

假设，我们有一个图形类`Shape`, 它具有一个属性和一个方法，属性为类型，方法为求图形的面积

```cpp
class Shape {
protected:
    string type;  // 形状类型
public:
    // 构造函数
    Shape(const string& shapeType) : type(shapeType) {}
    // 求面积的函数
    double getArea() const {
        return 0.0;
    }
    // 获取形状类型
    string getType() const {
        return type;
    }
};
```

在上面的代码中，`getArea`函数使用`const`用来修饰，是用来表示该函数不会修改对象的状态，使用`const`能保证对对象的访问是安全的。

```cpp
double getArea() const {
      // 不会修改对象的状态
      return 0.0;
}
```

要想实现继承，我们还需要一个关于圆的类`Circle`，它继承自`Shape`类

```cpp
// Circle 类，继承自 Shape
class Circle : public Shape {
private:
    int radius;  // 圆的半径
public:
    // 构造函数, 调用Shape的构造函数，初始化了类型为"circle"
    Circle(int circleRadius) : Shape("Circle"), radius(circleRadius) {}
    // 重写基类的方法
    double calculateArea() const override{
        return 3.14 * radius * radius;  // 圆的面积公式
    }
    // 获取半径
    int getRadius() const {
        return radius;
    }
};
```

在上面的示例代码中，图形类拥有`shape`属性和`getArea、getType`方法，而子类在父类这些属性和方法的基础上新增了`radius`属性和`getRadius`方法，并且在子类和父类中都有`getArea`这个方法，这被称为方法的重写，方法的重写需要`override`关键字，其意思是子类重写父类的方法，并提供自己的实现。

## 多态

多态常常和继承紧密相连，它允许不同的对象使用相同的接口进行操作，但在运行时表现出不同的行为。多态性使得可以使用**基类类型的指针或引用来引用派生类的对象，从而在运行时选择调用相应的派生类方法。**

C++中实现多态性的方法是通过`virtual`虚函数，比如下面的示例：

```cpp
class Shape {
public:
    virtual double calculateArea() const = 0;
};
class Circle : public Shape {
private:
    int radius;

public:
    double calculateArea() const override {
        return 3.14 * radius * radius;
    }
};
class Rectangle : public Shape {
private:
    int width;
    int height;

public:
    // 构造函数，用于初始化 width 和 height
    Rectangle(int w, int h) : width(w), height(h) {}
    // width * height 的结果是整数，但 calculateArea 方法的返回类型是 double
    // 为了确保结果是一个浮点数，使用 static_cast<double> 将其显式转换为 double 类型
       double calculateArea() const override {
        return static_cast<double>(width * height);
    }
};
```

这里使用`virtual`在父类中定义了一个虚函数，而`= 0`表示这是一个纯虚函数，即定义的函数在基类中没有实现，但是要求它的派生类都必须提供这个函数的实现，这种抽象的方法使得 `Shape` 类成为一个抽象基类，不能被实例化，只能被用作派生其他类的基类。

然后两个派生类 `Circle` 和 `Rectangle`则是重写了 `calculateArea` 方法，它们提供了各自的实现，有着不同的计算逻辑。

```cpp
int main() {
    std::vector<Shape*> shapes;

    shapes.push_back(new Rectangle(4, 5));
    shapes.push_back(new Circle(3));

    for (const Shape* shape : shapes) {
        std::cout << "Area: " << shape->calculateArea() << std::endl;
    }

    return 0;
}
```

之后我们创建了一个容器`shapes`，包含不同类型的图形对象，然后循环遍历该容器并为每一个`shape`对象调用 `calculateArea` 方法，尽管方法名称相同，但实际调用的方法是根据对象的类型动态确定的，这其实就是多态的概念。

## 例题

图形的面积

###### 题目描述

考虑一个简单的图形类层次结构，包括基类 Shape 和两个派生类 Rectangle 和 Circle。每个类都有一个用于计算面积的方法。你的任务是编写一个程序，根据输入数据创建一个图形对象，然后计算并输出其面积。

###### 输入描述

输入包括多行，每行包含一个图形的描述。 描述的第一个单词是图形类型（"rectangle"或"circle"），然后是与该图形相关的参数。 对于矩形，参数是宽度和高度，对于圆形，参数是半径。输入以单词"end"结束。

###### 输出描述

对于每个图形描述，输出其类型和面积。使用两位小数点精度输出面积。

###### 输入示例

```
rectangle 5 3
circle 2
end
```

###### 输出示例

```
Rectangle area: 15.00
Circle area: 12.56
```

###### 提示信息

长方形面积的计算 = 长 * 宽

圆形面积的计算 = 3.14 * 半径 * 半径

## 代码编写

我们之前已经做了很久的铺垫，根据题目要求，`Shape`类应该具有方法获取面积和类型。

```cpp
class Shape {
public:
      // 定义虚函数
      // const = 0 表示纯虚函数，该类不能被实例化，要求派生类必须实现这两个函数。
    virtual double CalculateArea() const = 0;
    virtual string GetType() const = 0;
};
```

之后，我们需要实现两个类`Rectangle`和`Circle`，它们都继承自类`Shape`

```cpp
class Rectangle : public Shape {
public:
    // 初始化参数列表
    Rectangle(int width, int height) : width(width), height(height) {}
    // 计算面积
    double CalculateArea() const override {
        return static_cast<double>(width * height);
    }
    // 获取类型
    string GetType() const override {
        return "Rectangle";
    }
// 属性：width和height
private:
    int width;
    int height;
};
class Circle : public Shape {
public:
    // 初始化参数列表
    Circle(int radius) : radius(radius) {}
    // 计算面积
    double CalculateArea() const override {
        return 3.14 * radius * radius;
    }
    // 获取类型
    std::string GetType() const override {
        return "Circle";
    }
// 属性：radius
private:
    int radius;
};
```

之后，我们可以定义一个容器`vector`，用来放置建立的示例，并处理输入输出

```cpp
int main() {
      // 定义一个容器，用来放置Shape类型
    vector<Shape*> shapes;
     
    return 0;
}
```

对输入的类型进行判断，如果是"end", 终止程序，如果是图形，则建立对应的实例

```cpp
while (true) {
      // 获取输入的类型
    string type;
    cin >> type;
    // 如果输入的是 "end"
    if (type == "end") {
        break;
    }
    // 如果输入的是 rectangle
    if (type == "rectangle") {
        int width, height;
        cin >> width >> height; // 获取输入的宽和高
        shapes.push_back(new Rectangle(width, height)); // 新建对象，放到容器中
    } else if (type == "circle") {
        int radius;
        cin >> radius; // 获取输入的半径
        shapes.push_back(new Circle(radius)); // 新建对象，放到容器中
    }
}
```

最后, 遍历列表，并输出面积即可，题目要求输出小数点后两位，可以引入`iomanip`库文件中的内容，当使用 `fixed` 时，浮点数会以固定小数点格式输出，`setprecision()`函数用于设置输出浮点数的精度，即小数点后的位数, `fixed << setprecision(2)`表示输出小数点后两位。

```cpp
// 输出结果，控制小数位数为两位
for (const Shape* shape : shapes) {
    cout << shape->GetType() << " area: " << fixed << setprecision(2) << shape->CalculateArea() << endl;
}
```

完整的代码如下：

```cpp
#include <iostream>
#include <vector>
#include <string>
// 引入iomanip库文件，用于控制输出格式
#include <iomanip>

using namespace std;
// Shpe类
class Shape {
public:
    // 定义计算面积和获取类型的函数为纯虚函数
    virtual double CalculateArea() const = 0;
    virtual string GetType() const = 0;
};

class Rectangle : public Shape {
public:
       // 初始化参数列表
    Rectangle(int width, int height) : width(width), height(height) {}
    // 计算长方形面积，将整数转为浮点数
    double CalculateArea() const override {
        return static_cast<double>(width * height);
    }
    // 获取图形的形状
    string GetType() const override {
        return "Rectangle";
    }
// 属性：宽度和高度
private:
    int width;
    int height;
};

class Circle : public Shape {
public:
    // 初始化参数列表
    Circle(int radius) : radius(radius) {}
    // 计算圆的面积
    double CalculateArea() const override {
        return 3.14 * radius * radius;
    }
    // 获取图形形状
    string GetType() const override {
        return "Circle";
    }
// 属性：半径
private:
    int radius;
};

int main() {
    // 定义一个容器，容纳 shape对象
    vector<Shape*> shapes;

    while (true) {
        string type;
        // 获取输入的 type类型
        cin >> type;

        if (type == "end") {
            break;
        }

        if (type == "rectangle") {
            // 获取输入的宽度和高度
            int width, height;
            cin >> width >> height;
            // 新建Rectangle对象
            shapes.push_back(new Rectangle(width, height));
        } else if (type == "circle") {
            int radius;
            // 获取输入的半径
            cin >> radius;
            // 新建 Radius 对象
            shapes.push_back(new Circle(radius));
        }
    }

    // 输出结果，控制小数位数为两位
    for (const Shape* shape : shapes) {
        // shape对象调用同一个方法，有不同的处理逻辑
        cout << shape->GetType() << " area: " << fixed << setprecision(2) << shape->CalculateArea() << endl;
    }

    return 0;
}
```

---

https://blog.csdn.net/dt927992/article/details/141258304

https://kamacoder.com/

[【C语言高阶篇】结构体 —— 什么是内存对齐？-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2374061)